<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Makefile">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Makefile" />
              <option name="originalContent" value=".PHONY: test-integration&#10;&#10;test-integration:&#10;&#9;docker-compose -f integration_tests/docker-compose.yml up -d --build&#10;&#9;go test -v ./integration_tests/...&#10;&#9;docker-compose -f integration_tests/docker-compose.yml down&#10;&#10;" />
              <option name="updatedContent" value=".PHONY: test-integration&#10;&#10;test-integration:&#10;&#9;docker-compose -f integration_tests/docker-compose.yml up -d --build&#10;&#9;docker-compose -f integration_tests/docker-compose.yml run --rm test-runner || (docker-compose -f integration_tests/docker-compose.yml logs &amp;&amp; docker-compose -f integration_tests/docker-compose.yml down &amp;&amp; exit 1)&#10;&#9;docker-compose -f integration_tests/docker-compose.yml down" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/README.md" />
              <option name="originalContent" value="# NATS TCP Proxy&#10;&#10;A high-performance TCP proxy that uses NATS (Neural Autonomic Transport System) as the transport layer for proxying TCP connections between client and server.&#10;&#10;## Architecture&#10;&#10;This project follows Domain-Driven Design (DDD) methodology with a client-server architecture:&#10;&#10;### Domain Layer&#10;- **Entities**: Connection, ProxySession&#10;- **Value Objects**: ConnectionID, Port, Host&#10;- **Domain Services**: ProxyService&#10;- ** Repositories**: ConnectionRepository&#10;&#10;### Application Layer&#10;- **Use Cases**: ProxyConnection, ManageConnections&#10;- **Services**: Application services that orchestrate domain objects&#10;&#10;### Infrastructure Layer&#10;- **Transport**: NATS implementation of abstract transport interface&#10;- **Persistence**: In-memory connection storage&#10;- **Configuration**: Viper-based configuration management&#10;&#10;### Interface Layer&#10;- **CLI Commands**: Client and Server commands using Cobra&#10;- **APIs**: REST endpoints (future enhancement)&#10;&#10;## Client-Server Flow&#10;&#10;The proxy operates with a **dynamic worker model**:&#10;&#10;1. **Client** specifies the remote target (host:port) when starting&#10;2. **Client** listens on a local port and forwards connections through NATS&#10;3. **Server** receives NATS messages with remote target information&#10;4. **Server** creates separate internal workers for each connection&#10;5. **Workers** establish connections to the specified remote targets&#10;6. **Bidirectional data flow** occurs through NATS between client and server workers&#10;&#10;## Features&#10;&#10;- **Dynamic Worker Model**: Server creates separate workers for each connection&#10;- **Client-Specified Targets**: Remote host/port specified by client, not server&#10;- **Multi-Connection Support**: Handle multiple concurrent TCP connections&#10;- **Abstract Transport**: Pluggable transport layer (currently NATS)&#10;- **DDD Architecture**: Clean separation of concerns&#10;- **CLI Interface**: Easy-to-use command-line tools&#10;- **Configuration**: Flexible configuration management&#10;- **Logging**: Structured logging with logrus&#10;&#10;## Project Structure&#10;&#10;```&#10;nats-proxy/&#10;├── cmd/&#10;│   ├── client/          # Client CLI application&#10;│   └── server/          # Server CLI application&#10;├── internal/&#10;│   ├── domain/          # Domain layer (entities, value objects, services)&#10;│   ├── application/     # Application layer (use cases, services)&#10;│   ├── infrastructure/  # Infrastructure layer (transport, persistence)&#10;│   └── interfaces/      # Interface layer (CLI, APIs)&#10;├── pkg/&#10;│   └── transport/       # Abstract transport interface&#10;├── examples/            # Usage examples&#10;├── docs/               # Documentation&#10;└── scripts/            # Build and deployment scripts&#10;```&#10;&#10;## Quick Start&#10;&#10;### Prerequisites&#10;&#10;- Go 1.21 or higher&#10;- NATS server running (local or cloud)&#10;&#10;### Installation&#10;&#10;```bash&#10;go mod tidy&#10;go build ./cmd/client&#10;go build ./cmd/server&#10;```&#10;&#10;### Docker Deployment&#10;&#10;For production deployment, you can use Docker:&#10;&#10;```bash&#10;# Build and run server with Docker&#10;./scripts/docker-server.sh build&#10;./scripts/docker-server.sh run&#10;&#10;# Or use Docker Compose (includes NATS and Redis)&#10;./scripts/docker-server.sh compose&#10;```&#10;&#10;### Running the Server&#10;&#10;```bash&#10;./server --nats-url nats://localhost:4222&#10;```&#10;&#10;### Running the Client&#10;&#10;```bash&#10;./client --nats-url nats://localhost:4222 --local-port 6380 --remote-host localhost --remote-port 6379&#10;```&#10;&#10;## Configuration&#10;&#10;### Server Configuration&#10;&#10;- `--nats-url`: NATS server URL (default: nats://localhost:4222)&#10;- `--log-level`: Log level (debug, info, warn, error)&#10;&#10;### Client Configuration&#10;&#10;- `--nats-url`: NATS server URL (default: nats://localhost:4222)&#10;- `--local-port`: Local port to listen on&#10;- `--remote-host`: Target remote host&#10;- `--remote-port`: Target remote port&#10;- `--log-level`: Log level (debug, info, warn, error)&#10;&#10;## Examples&#10;&#10;### Redis Proxy Example&#10;&#10;1. Start NATS server:&#10;```bash&#10;nats-server&#10;```&#10;&#10;2. Start the proxy server (pointing to Redis):&#10;```bash&#10;./server --nats-url nats://localhost:4222 --remote-host localhost --remote-port 6379&#10;```&#10;&#10;3. Start the proxy client:&#10;```bash&#10;./client --nats-url nats://localhost:4222 --local-port 6380&#10;```&#10;&#10;4. Connect to Redis through the proxy:&#10;```bash&#10;redis-cli -p 6380&#10;```&#10;&#10;## Development&#10;&#10;### Building&#10;&#10;```bash&#10;make build&#10;```&#10;&#10;### Testing&#10;&#10;```bash&#10;make test&#10;```&#10;&#10;### Running Examples&#10;&#10;```bash&#10;make run-examples&#10;```&#10;&#10;### Docker Development&#10;&#10;```bash&#10;# Build server Docker image&#10;./scripts/docker-server.sh build&#10;&#10;# Run server container&#10;./scripts/docker-server.sh run&#10;&#10;# View logs&#10;./scripts/docker-server.sh logs&#10;&#10;# Stop container&#10;./scripts/docker-server.sh stop&#10;&#10;# Clean up&#10;./scripts/docker-server.sh clean&#10;```&#10;&#10;### Integration Testing&#10;&#10;```bash&#10;# Run full integration tests with cleanup&#10;make integration-test&#10;&#10;# Run quick integration test (no cleanup)&#10;make integration-test-quick&#10;&#10;# Or run directly with options&#10;./scripts/integration-test.sh -c -v&#10;&#10;# Run with custom TTL duration for TTL tests (default: 5 seconds)&#10;./scripts/integration-test.sh --ttl 10&#10;&#10;# Show all available options&#10;./scripts/integration-test.sh --help&#10;```&#10;&#10;The integration tests include comprehensive TTL (Time To Live) tests that verify:&#10;- Basic SETEX operations with expiration&#10;- EXPIRE command functionality&#10;- PERSIST command for removing TTL from keys&#10;&#10;These tests ensure that the proxy correctly handles Redis TTL operations, allowing applications to use expiring keys through the proxy.&#10;&#10;### GitHub Release&#10;&#10;```bash&#10;# Create a release (requires GitHub token)&#10;./scripts/github-release.sh -t v1.0.0 -g YOUR_GITHUB_TOKEN&#10;&#10;# Create a draft release&#10;./scripts/github-release.sh -t v1.0.0-rc1 -d -p&#10;&#10;# Skip tests for quick release&#10;./scripts/github-release.sh -t v1.0.0 -s&#10;```&#10;&#10;## Contributing&#10;&#10;1. Fork the repository&#10;2. Create a feature branch&#10;3. Make your changes&#10;4. Add tests&#10;5. Submit a pull request&#10;&#10;## License&#10;&#10;MIT License&#10;" />
              <option name="updatedContent" value="# NATS TCP Proxy&#10;&#10;A high-performance TCP proxy that uses NATS (Neural Autonomic Transport System) as the transport layer for proxying TCP connections between client and server.&#10;&#10;## Architecture&#10;&#10;This project follows Domain-Driven Design (DDD) methodology with a client-server architecture:&#10;&#10;### Domain Layer&#10;- **Entities**: Connection, ProxySession&#10;- **Value Objects**: ConnectionID, Port, Host&#10;- **Domain Services**: ProxyService&#10;- ** Repositories**: ConnectionRepository&#10;&#10;### Application Layer&#10;- **Use Cases**: ProxyConnection, ManageConnections&#10;- **Services**: Application services that orchestrate domain objects&#10;&#10;### Infrastructure Layer&#10;- **Transport**: NATS implementation of abstract transport interface&#10;- **Persistence**: In-memory connection storage&#10;- **Configuration**: Viper-based configuration management&#10;&#10;### Interface Layer&#10;- **CLI Commands**: Client and Server commands using Cobra&#10;- **APIs**: REST endpoints (future enhancement)&#10;&#10;## Client-Server Flow&#10;&#10;The proxy operates with a **dynamic worker model**:&#10;&#10;1. **Client** specifies the remote target (host:port) when starting&#10;2. **Client** listens on a local port and forwards connections through NATS&#10;3. **Server** receives NATS messages with remote target information&#10;4. **Server** creates separate internal workers for each connection&#10;5. **Workers** establish connections to the specified remote targets&#10;6. **Bidirectional data flow** occurs through NATS between client and server workers&#10;&#10;## Features&#10;&#10;- **Dynamic Worker Model**: Server creates separate workers for each connection&#10;- **Client-Specified Targets**: Remote host/port specified by client, not server&#10;- **Multi-Connection Support**: Handle multiple concurrent TCP connections&#10;- **Abstract Transport**: Pluggable transport layer (currently NATS)&#10;- **DDD Architecture**: Clean separation of concerns&#10;- **CLI Interface**: Easy-to-use command-line tools&#10;- **Configuration**: Flexible configuration management&#10;- **Logging**: Structured logging with logrus&#10;&#10;## Project Structure&#10;&#10;```&#10;nats-proxy/&#10;├── cmd/&#10;│   ├── client/          # Client CLI application&#10;│   └── server/          # Server CLI application&#10;├── internal/&#10;│   ├── domain/          # Domain layer (entities, value objects, services)&#10;│   ├── application/     # Application layer (use cases, services)&#10;│   ├── infrastructure/  # Infrastructure layer (transport, persistence)&#10;│   └── interfaces/      # Interface layer (CLI, APIs)&#10;├── pkg/&#10;│   └── transport/       # Abstract transport interface&#10;├── examples/            # Usage examples&#10;├── docs/               # Documentation&#10;└── scripts/            # Build and deployment scripts&#10;```&#10;&#10;## Quick Start&#10;&#10;### Prerequisites&#10;&#10;- Go 1.21 or higher&#10;- NATS server running (local or cloud)&#10;&#10;### Installation&#10;&#10;```bash&#10;go mod tidy&#10;go build ./cmd/client&#10;go build ./cmd/server&#10;```&#10;&#10;### Docker Deployment&#10;&#10;For production deployment, you can use Docker:&#10;&#10;```bash&#10;# Build and run server with Docker&#10;./scripts/docker-server.sh build&#10;./scripts/docker-server.sh run&#10;&#10;# Or use Docker Compose (includes NATS and Redis)&#10;./scripts/docker-server.sh compose&#10;```&#10;&#10;### Running the Server&#10;&#10;```bash&#10;./server --nats-url nats://localhost:4222&#10;```&#10;&#10;### Running the Client&#10;&#10;```bash&#10;./client --nats-url nats://localhost:4222 --local-port 6380 --remote-host localhost --remote-port 6379&#10;```&#10;&#10;## Configuration&#10;&#10;### Server Configuration&#10;&#10;- `--nats-url`: NATS server URL (default: nats://localhost:4222)&#10;- `--log-level`: Log level (debug, info, warn, error)&#10;&#10;### Client Configuration&#10;&#10;- `--nats-url`: NATS server URL (default: nats://localhost:4222)&#10;- `--local-port`: Local port to listen on&#10;- `--remote-host`: Target remote host&#10;- `--remote-port`: Target remote port&#10;- `--log-level`: Log level (debug, info, warn, error)&#10;&#10;## Examples&#10;&#10;### Redis Proxy Example&#10;&#10;1. Start NATS server:&#10;```bash&#10;nats-server&#10;```&#10;&#10;2. Start the proxy server (pointing to Redis):&#10;```bash&#10;./server --nats-url nats://localhost:4222 --remote-host localhost --remote-port 6379&#10;```&#10;&#10;3. Start the proxy client:&#10;```bash&#10;./client --nats-url nats://localhost:4222 --local-port 6380&#10;```&#10;&#10;4. Connect to Redis through the proxy:&#10;```bash&#10;redis-cli -p 6380&#10;```&#10;&#10;## Development&#10;&#10;### Building&#10;&#10;```bash&#10;make build&#10;```&#10;&#10;### Testing&#10;&#10;```bash&#10;make test&#10;```&#10;&#10;### Running Examples&#10;&#10;```bash&#10;make run-examples&#10;```&#10;&#10;### Docker Development&#10;&#10;```bash&#10;# Build server Docker image&#10;./scripts/docker-server.sh build&#10;&#10;# Run server container&#10;./scripts/docker-server.sh run&#10;&#10;# View logs&#10;./scripts/docker-server.sh logs&#10;&#10;# Stop container&#10;./scripts/docker-server.sh stop&#10;```&#10;&#10;### GitHub Release&#10;&#10;```bash&#10;# Create a release (requires GitHub token)&#10;./scripts/github-release.sh -t v1.0.0 -g YOUR_GITHUB_TOKEN&#10;&#10;# Create a draft release&#10;./scripts/github-release.sh -t v1.0.0-rc1 -d -p&#10;&#10;# Skip tests for quick release&#10;./scripts/github-release.sh -t v1.0.0 -s&#10;```&#10;&#10;## Contributing&#10;&#10;1. Fork the repository&#10;2. Create a feature branch&#10;3. Make your changes&#10;4. Add tests&#10;5. Submit a pull request&#10;&#10;## License&#10;&#10;MIT License" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/cmd/client/main.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/cmd/client/main.go" />
              <option name="originalContent" value="package main&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;net&quot;&#10;&#9;&quot;os&quot;&#10;&#9;&quot;os/signal&quot;&#10;&#9;&quot;syscall&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;natsTransport &quot;github.com/igorrius/tcp-sproxy/internal/infrastructure/transport&quot;&#10;&#9;&quot;github.com/sirupsen/logrus&quot;&#10;&#9;&quot;github.com/spf13/cobra&quot;&#10;&#9;&quot;github.com/spf13/viper&quot;&#10;)&#10;&#10;var (&#10;&#9;cfgFile  string&#10;&#9;logLevel string&#10;)&#10;&#10;func main() {&#10;&#9;Execute()&#10;}&#10;&#10;var rootCmd = &amp;cobra.Command{&#10;&#9;Use:   &quot;nats-proxy-client&quot;,&#10;&#9;Short: &quot;NATS TCP Proxy Client&quot;,&#10;&#9;Long: `A TCP proxy client that uses NATS as the transport layer.&#10;This client listens on a local port and forwards connections to a remote server via NATS.`,&#10;&#9;RunE: runClient,&#10;}&#10;&#10;func Execute() {&#10;&#9;if err := rootCmd.Execute(); err != nil {&#10;&#9;&#9;fmt.Fprintln(os.Stderr, err)&#10;&#9;&#9;os.Exit(1)&#10;&#9;}&#10;}&#10;&#10;func init() {&#10;&#9;cobra.OnInitialize(initConfig)&#10;&#10;&#9;rootCmd.PersistentFlags().StringVar(&amp;cfgFile, &quot;config&quot;, &quot;&quot;, &quot;config file (default is $HOME/.nats-proxy-client.yaml)&quot;)&#10;&#9;rootCmd.PersistentFlags().StringVar(&amp;logLevel, &quot;log-level&quot;, &quot;info&quot;, &quot;log level (debug, info, warn, error)&quot;)&#10;&#10;&#9;// Client-specific flags&#10;&#9;rootCmd.Flags().String(&quot;nats-url&quot;, &quot;nats://localhost:4222&quot;, &quot;NATS server URL&quot;)&#10;&#9;rootCmd.Flags().String(&quot;listen-addr&quot;, &quot;localhost:8082&quot;, &quot;Local address to listen on&quot;)&#10;&#9;rootCmd.Flags().String(&quot;remote-addr&quot;, &quot;&quot;, &quot;Remote address to proxy to&quot;)&#10;&#9;rootCmd.Flags().String(&quot;proxy-addr&quot;, &quot;&quot;, &quot;Proxy address to connect to&quot;)&#10;&#10;&#9;// Bind flags to viper&#10;&#9;viper.BindPFlag(&quot;nats.url&quot;, rootCmd.Flags().Lookup(&quot;nats-url&quot;))&#10;&#9;viper.BindPFlag(&quot;client.listen_addr&quot;, rootCmd.Flags().Lookup(&quot;listen-addr&quot;))&#10;&#9;viper.BindPFlag(&quot;client.remote_addr&quot;, rootCmd.Flags().Lookup(&quot;remote-addr&quot;))&#10;&#9;viper.BindPFlag(&quot;client.proxy_addr&quot;, rootCmd.Flags().Lookup(&quot;proxy-addr&quot;))&#10;&#9;viper.BindPFlag(&quot;log.level&quot;, rootCmd.PersistentFlags().Lookup(&quot;log-level&quot;))&#10;}&#10;&#10;func initConfig() {&#10;&#9;if cfgFile != &quot;&quot; {&#10;&#9;&#9;viper.SetConfigFile(cfgFile)&#10;&#9;} else {&#10;&#9;&#9;viper.AddConfigPath(&quot;.&quot;)&#10;&#9;&#9;viper.AddConfigPath(&quot;$HOME&quot;)&#10;&#9;&#9;viper.SetConfigName(&quot;.nats-proxy-client&quot;)&#10;&#9;}&#10;&#10;&#9;viper.AutomaticEnv()&#10;&#10;&#9;// Map environment variables to viper keys&#10;&#9;viper.BindEnv(&quot;nats.url&quot;, &quot;NATS_URL&quot;)&#10;&#9;viper.BindEnv(&quot;client.listen_addr&quot;, &quot;LISTEN_ADDR&quot;)&#10;&#9;viper.BindEnv(&quot;client.remote_addr&quot;, &quot;REMOTE_ADDR&quot;)&#10;&#9;viper.BindEnv(&quot;client.proxy_addr&quot;, &quot;PROXY_ADDR&quot;)&#10;&#9;viper.BindEnv(&quot;log.level&quot;, &quot;LOG_LEVEL&quot;)&#10;&#10;&#9;if err := viper.ReadInConfig(); err == nil {&#10;&#9;&#9;fmt.Println(&quot;Using config file:&quot;, viper.ConfigFileUsed())&#10;&#9;}&#10;}&#10;&#10;func runClient(cmd *cobra.Command, args []string) error {&#10;&#9;// Setup logging&#10;&#9;level, err := logrus.ParseLevel(viper.GetString(&quot;log.level&quot;))&#10;&#9;if err != nil {&#10;&#9;&#9;return fmt.Errorf(&quot;invalid log level: %w&quot;, err)&#10;&#9;}&#10;&#9;logrus.SetLevel(level)&#10;&#9;logrus.SetFormatter(&amp;logrus.TextFormatter{&#10;&#9;&#9;FullTimestamp: true,&#10;&#9;})&#10;&#10;&#9;logger := logrus.WithField(&quot;component&quot;, &quot;client&quot;)&#10;&#9;logger.Info(&quot;Starting NATS TCP Proxy Client&quot;)&#10;&#10;&#9;natsURL := viper.GetString(&quot;nats.url&quot;)&#10;&#9;listenAddr := viper.GetString(&quot;client.listen_addr&quot;)&#10;&#9;remoteAddr := viper.GetString(&quot;client.remote_addr&quot;)&#10;&#9;proxyAddr := viper.GetString(&quot;client.proxy_addr&quot;)&#10;&#10;&#9;if listenAddr == &quot;&quot; {&#10;&#9;&#9;return fmt.Errorf(&quot;listen address is required&quot;)&#10;&#9;}&#10;&#9;if remoteAddr == &quot;&quot; {&#10;&#9;&#9;return fmt.Errorf(&quot;remote address is required&quot;)&#10;&#9;}&#10;&#9;if proxyAddr == &quot;&quot; {&#10;&#9;&#9;return fmt.Errorf(&quot;proxy address is required&quot;)&#10;&#9;}&#10;&#10;&#9;logger.Infof(&quot;NATS URL: %s&quot;, natsURL)&#10;&#9;logger.Infof(&quot;Listening on: %s&quot;, listenAddr)&#10;&#9;logger.Infof(&quot;Proxying to: %s&quot;, remoteAddr)&#10;&#9;logger.Infof(&quot;via Proxy Server: %s&quot;, proxyAddr)&#10;&#10;&#9;// Create a new NATS transport&#10;&#9;transport, err := natsTransport.NewNATSTransport(natsURL, logger)&#10;&#9;if err != nil {&#10;&#9;&#9;return fmt.Errorf(&quot;failed to create NATS transport: %w&quot;, err)&#10;&#9;}&#10;&#9;defer transport.Close()&#10;&#10;&#9;// Start listening for incoming connections&#10;&#9;listener, err := net.Listen(&quot;tcp&quot;, listenAddr)&#10;&#9;if err != nil {&#10;&#9;&#9;return fmt.Errorf(&quot;failed to listen on %s: %w&quot;, listenAddr, err)&#10;&#9;}&#10;&#9;defer listener.Close()&#10;&#10;&#9;logger.Infof(&quot;Client started successfully, waiting for connections on %s&quot;, listenAddr)&#10;&#10;&#9;// Handle graceful shutdown&#10;&#9;ctx, cancel := context.WithCancel(context.Background())&#10;&#9;defer cancel()&#10;&#10;&#9;sigChan := make(chan os.Signal, 1)&#10;&#9;signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)&#10;&#10;&#9;// Accept connections&#10;&#9;go func() {&#10;&#9;&#9;for {&#10;&#9;&#9;&#9;conn, err := listener.Accept()&#10;&#9;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;&#9;select {&#10;&#9;&#9;&#9;&#9;case &lt;-ctx.Done():&#10;&#9;&#9;&#9;&#9;&#9;return&#10;&#9;&#9;&#9;&#9;default:&#10;&#9;&#9;&#9;&#9;&#9;logger.WithError(err).Error(&quot;Failed to accept connection&quot;)&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;continue&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;go func(conn net.Conn) {&#10;&#9;&#9;&#9;&#9;defer conn.Close()&#10;&#9;&#9;&#9;&#9;logger.Infof(&quot;Accepted connection from %s&quot;, conn.RemoteAddr())&#10;&#10;&#9;&#9;&#9;&#9;proxyConn, err := transport.Dial(ctx, proxyAddr, remoteAddr)&#10;&#9;&#9;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;&#9;&#9;logger.WithError(err).Errorf(&quot;Failed to dial proxy&quot;)&#10;&#9;&#9;&#9;&#9;&#9;return&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;defer proxyConn.Close()&#10;&#10;&#9;&#9;&#9;&#9;logger.Infof(&quot;Proxy connection established to %s&quot;, proxyConn.RemoteAddr())&#10;&#10;&#9;&#9;&#9;&#9;errCh := make(chan error, 2)&#10;&#9;&#9;&#9;&#9;go func() {&#10;&#9;&#9;&#9;&#9;&#9;_, err := transport.Proxy(conn, proxyConn)&#10;&#9;&#9;&#9;&#9;&#9;errCh &lt;- err&#10;&#9;&#9;&#9;&#9;}()&#10;&#9;&#9;&#9;&#9;go func() {&#10;&#9;&#9;&#9;&#9;&#9;_, err := transport.Proxy(proxyConn, conn)&#10;&#9;&#9;&#9;&#9;&#9;errCh &lt;- err&#10;&#9;&#9;&#9;&#9;}()&#10;&#10;&#9;&#9;&#9;&#9;select {&#10;&#9;&#9;&#9;&#9;case err := &lt;-errCh:&#10;&#9;&#9;&#9;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;&#9;&#9;&#9;logger.WithError(err).Error(&quot;Proxy error&quot;)&#10;&#9;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;case &lt;-ctx.Done():&#10;&#9;&#9;&#9;&#9;&#9;logger.Info(&quot;Context cancelled&quot;)&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;logger.Infof(&quot;Connection from %s closed&quot;, conn.RemoteAddr())&#10;&#9;&#9;&#9;}(conn)&#10;&#9;&#9;}&#10;&#9;}()&#10;&#10;&#9;// Wait for shutdown signal&#10;&#9;&lt;-sigChan&#10;&#9;logger.Info(&quot;Shutting down client...&quot;)&#10;&#9;cancel() // Cancel context to stop accepting new connections and close existing ones&#10;&#10;&#9;// Give connections time to close gracefully&#10;&#9;time.Sleep(2 * time.Second)&#10;&#10;&#9;logger.Info(&quot;Client shutdown complete&quot;)&#10;&#10;&#9;return nil&#10;}&#10;" />
              <option name="updatedContent" value="package main&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;net&quot;&#10;&#9;&quot;os&quot;&#10;&#9;&quot;os/signal&quot;&#10;&#9;&quot;syscall&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;natsTransport &quot;github.com/igorrius/tcp-sproxy/internal/infrastructure/transport&quot;&#10;&#9;&quot;github.com/sirupsen/logrus&quot;&#10;&#9;&quot;github.com/spf13/cobra&quot;&#10;&#9;&quot;github.com/spf13/viper&quot;&#10;)&#10;&#10;var (&#10;&#9;cfgFile  string&#10;&#9;logLevel string&#10;)&#10;&#10;func main() {&#10;&#9;Execute()&#10;}&#10;&#10;var rootCmd = &amp;cobra.Command{&#10;&#9;Use:   &quot;nats-proxy-client&quot;,&#10;&#9;Short: &quot;NATS TCP Proxy Client&quot;,&#10;&#9;Long: `A TCP proxy client that uses NATS as the transport layer.&#10;This client listens on a local port and forwards connections to a remote server via NATS.`,&#10;&#9;RunE: runClient,&#10;}&#10;&#10;func Execute() {&#10;&#9;if err := rootCmd.Execute(); err != nil {&#10;&#9;&#9;fmt.Fprintln(os.Stderr, err)&#10;&#9;&#9;os.Exit(1)&#10;&#9;}&#10;}&#10;&#10;func init() {&#10;&#9;cobra.OnInitialize(initConfig)&#10;&#10;&#9;rootCmd.PersistentFlags().StringVar(&amp;cfgFile, &quot;config&quot;, &quot;&quot;, &quot;config file (default is $HOME/.nats-proxy-client.yaml)&quot;)&#10;&#9;rootCmd.PersistentFlags().StringVar(&amp;logLevel, &quot;log-level&quot;, &quot;info&quot;, &quot;log level (debug, info, warn, error)&quot;)&#10;&#10;&#9;// Client-specific flags&#10;&#9;rootCmd.Flags().String(&quot;nats-url&quot;, &quot;nats://localhost:4222&quot;, &quot;NATS server URL&quot;)&#10;&#9;rootCmd.Flags().String(&quot;listen-addr&quot;, &quot;0.0.0.0:8082&quot;, &quot;Address to listen on for incoming connections&quot;)&#10;&#9;rootCmd.Flags().String(&quot;remote-addr&quot;, &quot;redis:6379&quot;, &quot;Remote address to proxy to&quot;)&#10;&#9;rootCmd.Flags().String(&quot;proxy-addr&quot;, &quot;proxy-server:8081&quot;, &quot;Proxy server address&quot;)&#10;&#10;&#9;// Bind flags to viper&#10;&#9;viper.BindPFlag(&quot;nats.url&quot;, rootCmd.Flags().Lookup(&quot;nats-url&quot;))&#10;&#9;viper.BindPFlag(&quot;client.listen_addr&quot;, rootCmd.Flags().Lookup(&quot;listen-addr&quot;))&#10;&#9;viper.BindPFlag(&quot;client.remote_addr&quot;, rootCmd.Flags().Lookup(&quot;remote-addr&quot;))&#10;&#9;viper.BindPFlag(&quot;client.proxy_addr&quot;, rootCmd.Flags().Lookup(&quot;proxy-addr&quot;))&#10;&#9;viper.BindPFlag(&quot;log.level&quot;, rootCmd.PersistentFlags().Lookup(&quot;log-level&quot;))&#10;}&#10;&#10;func initConfig() {&#10;&#9;if cfgFile != &quot;&quot; {&#10;&#9;&#9;viper.SetConfigFile(cfgFile)&#10;&#9;} else {&#10;&#9;&#9;viper.AddConfigPath(&quot;.&quot;)&#10;&#9;&#9;viper.AddConfigPath(&quot;$HOME&quot;)&#10;&#9;&#9;viper.SetConfigName(&quot;.nats-proxy-client&quot;)&#10;&#9;}&#10;&#10;&#9;viper.AutomaticEnv()&#10;&#10;&#9;// Map environment variables to viper keys&#10;&#9;viper.BindEnv(&quot;nats.url&quot;, &quot;NATS_URL&quot;)&#10;&#9;viper.BindEnv(&quot;client.listen_addr&quot;, &quot;LISTEN_ADDR&quot;)&#10;&#9;viper.BindEnv(&quot;client.remote_addr&quot;, &quot;REMOTE_ADDR&quot;)&#10;&#9;viper.BindEnv(&quot;client.proxy_addr&quot;, &quot;PROXY_ADDR&quot;)&#10;&#9;viper.BindEnv(&quot;log.level&quot;, &quot;LOG_LEVEL&quot;)&#10;&#10;&#9;if err := viper.ReadInConfig(); err == nil {&#10;&#9;&#9;fmt.Println(&quot;Using config file:&quot;, viper.ConfigFileUsed())&#10;&#9;}&#10;}&#10;&#10;func runClient(cmd *cobra.Command, args []string) error {&#10;&#9;// Setup logging&#10;&#9;level, err := logrus.ParseLevel(viper.GetString(&quot;log.level&quot;))&#10;&#9;if err != nil {&#10;&#9;&#9;return fmt.Errorf(&quot;invalid log level: %w&quot;, err)&#10;&#9;}&#10;&#9;logrus.SetLevel(level)&#10;&#9;logrus.SetFormatter(&amp;logrus.TextFormatter{&#10;&#9;&#9;FullTimestamp: true,&#10;&#9;})&#10;&#10;&#9;logger := logrus.WithField(&quot;component&quot;, &quot;client&quot;)&#10;&#9;logger.Info(&quot;Starting NATS TCP Proxy Client&quot;)&#10;&#10;&#9;natsURL := viper.GetString(&quot;nats.url&quot;)&#10;&#9;listenAddr := viper.GetString(&quot;client.listen_addr&quot;)&#10;&#9;remoteAddr := viper.GetString(&quot;client.remote_addr&quot;)&#10;&#9;proxyAddr := viper.GetString(&quot;client.proxy_addr&quot;)&#10;&#10;&#9;if listenAddr == &quot;&quot; {&#10;&#9;&#9;return fmt.Errorf(&quot;listen address is required&quot;)&#10;&#9;}&#10;&#9;if remoteAddr == &quot;&quot; {&#10;&#9;&#9;return fmt.Errorf(&quot;remote address is required&quot;)&#10;&#9;}&#10;&#9;if proxyAddr == &quot;&quot; {&#10;&#9;&#9;return fmt.Errorf(&quot;proxy address is required&quot;)&#10;&#9;}&#10;&#10;&#9;logger.Infof(&quot;NATS URL: %s&quot;, natsURL)&#10;&#9;logger.Infof(&quot;Listening on: %s&quot;, listenAddr)&#10;&#9;logger.Infof(&quot;Proxying to: %s&quot;, remoteAddr)&#10;&#9;logger.Infof(&quot;via Proxy Server: %s&quot;, proxyAddr)&#10;&#10;&#9;// Create a new NATS transport&#10;&#9;transport := natsTransport.NewNATSTransport(logger)&#10;&#9;err = transport.Connect(context.Background(), &amp;natsTransport.NATSConfig{&#10;&#9;&#9;URL: natsURL,&#10;&#9;})&#10;&#9;if err != nil {&#10;&#9;&#9;return fmt.Errorf(&quot;failed to connect to NATS: %w&quot;, err)&#10;&#9;}&#10;&#9;defer transport.Close()&#10;&#10;&#9;// Start listening for incoming connections&#10;&#9;listener, err := net.Listen(&quot;tcp&quot;, listenAddr)&#10;&#9;if err != nil {&#10;&#9;&#9;return fmt.Errorf(&quot;failed to listen on %s: %w&quot;, listenAddr, err)&#10;&#9;}&#10;&#9;defer listener.Close()&#10;&#10;&#9;logger.Infof(&quot;Client started successfully, waiting for connections on %s&quot;, listenAddr)&#10;&#10;&#9;// Handle graceful shutdown&#10;&#9;ctx, cancel := context.WithCancel(context.Background())&#10;&#9;defer cancel()&#10;&#10;&#9;sigChan := make(chan os.Signal, 1)&#10;&#9;signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)&#10;&#10;&#9;// Accept connections&#10;&#9;go func() {&#10;&#9;&#9;for {&#10;&#9;&#9;&#9;conn, err := listener.Accept()&#10;&#9;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;&#9;select {&#10;&#9;&#9;&#9;&#9;case &lt;-ctx.Done():&#10;&#9;&#9;&#9;&#9;&#9;return&#10;&#9;&#9;&#9;&#9;default:&#10;&#9;&#9;&#9;&#9;&#9;logger.WithError(err).Error(&quot;Failed to accept connection&quot;)&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;continue&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;go func(conn net.Conn) {&#10;&#9;&#9;&#9;&#9;defer conn.Close()&#10;&#9;&#9;&#9;&#9;logger.Infof(&quot;Accepted connection from %s&quot;, conn.RemoteAddr())&#10;&#10;&#9;&#9;&#9;&#9;proxyConn, err := transport.Dial(ctx, proxyAddr, remoteAddr)&#10;&#9;&#9;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;&#9;&#9;logger.WithError(err).Errorf(&quot;Failed to dial proxy&quot;)&#10;&#9;&#9;&#9;&#9;&#9;return&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;defer proxyConn.Close()&#10;&#10;&#9;&#9;&#9;&#9;logger.Infof(&quot;Proxy connection established to %s&quot;, proxyConn.RemoteAddr())&#10;&#10;&#9;&#9;&#9;&#9;errCh := make(chan error, 2)&#10;&#9;&#9;&#9;&#9;go func() {&#10;&#9;&#9;&#9;&#9;&#9;_, err := transport.Proxy(conn, proxyConn)&#10;&#9;&#9;&#9;&#9;&#9;errCh &lt;- err&#10;&#9;&#9;&#9;&#9;}()&#10;&#9;&#9;&#9;&#9;go func() {&#10;&#9;&#9;&#9;&#9;&#9;_, err := transport.Proxy(proxyConn, conn)&#10;&#9;&#9;&#9;&#9;&#9;errCh &lt;- err&#10;&#9;&#9;&#9;&#9;}()&#10;&#10;&#9;&#9;&#9;&#9;select {&#10;&#9;&#9;&#9;&#9;case err := &lt;-errCh:&#10;&#9;&#9;&#9;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;&#9;&#9;&#9;logger.WithError(err).Error(&quot;Proxy error&quot;)&#10;&#9;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;case &lt;-ctx.Done():&#10;&#9;&#9;&#9;&#9;&#9;logger.Info(&quot;Context cancelled&quot;)&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;logger.Infof(&quot;Connection from %s closed&quot;, conn.RemoteAddr())&#10;&#9;&#9;&#9;}(conn)&#10;&#9;&#9;}&#10;&#9;}()&#10;&#10;&#9;// Wait for shutdown signal&#10;&#9;&lt;-sigChan&#10;&#9;logger.Info(&quot;Shutting down client...&quot;)&#10;&#9;cancel() // Cancel context to stop accepting new connections and close existing ones&#10;&#10;&#9;// Give connections time to close gracefully&#10;&#9;time.Sleep(2 * time.Second)&#10;&#10;&#9;logger.Info(&quot;Client shutdown complete&quot;)&#10;&#10;&#9;return nil&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/cmd/server/main.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/cmd/server/main.go" />
              <option name="originalContent" value="package main&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;os&quot;&#10;&#9;&quot;os/signal&quot;&#10;&#9;&quot;syscall&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;github.com/igorrius/tcp-sproxy/internal/application/usecases&quot;&#10;&#9;&quot;github.com/igorrius/tcp-sproxy/internal/domain/services&quot;&#10;&#9;&quot;github.com/igorrius/tcp-sproxy/internal/infrastructure/repositories&quot;&#10;&#9;&quot;github.com/igorrius/tcp-sproxy/internal/infrastructure/transport&quot;&#10;&#9;&quot;github.com/sirupsen/logrus&quot;&#10;&#9;&quot;github.com/spf13/cobra&quot;&#10;&#9;&quot;github.com/spf13/viper&quot;&#10;)&#10;&#10;var (&#10;&#9;cfgFile  string&#10;&#9;logLevel string&#10;)&#10;&#10;func main() {&#10;&#9;Execute()&#10;}&#10;&#10;var rootCmd = &amp;cobra.Command{&#10;&#9;Use:   &quot;nats-proxy-server&quot;,&#10;&#9;Short: &quot;NATS TCP Proxy Server&quot;,&#10;&#9;Long: `A TCP proxy server that uses NATS as the transport layer.&#10;This server accepts connections and forwards them to a remote host using NATS.`,&#10;&#9;RunE: runServer,&#10;}&#10;&#10;func Execute() {&#10;&#9;if err := rootCmd.Execute(); err != nil {&#10;&#9;&#9;fmt.Fprintln(os.Stderr, err)&#10;&#9;&#9;os.Exit(1)&#10;&#9;}&#10;}&#10;&#10;func init() {&#10;&#9;cobra.OnInitialize(initConfig)&#10;&#10;&#9;rootCmd.PersistentFlags().StringVar(&amp;cfgFile, &quot;config&quot;, &quot;&quot;, &quot;config file (default is $HOME/.nats-proxy-server.yaml)&quot;)&#10;&#9;rootCmd.PersistentFlags().StringVar(&amp;logLevel, &quot;log-level&quot;, &quot;info&quot;, &quot;log level (debug, info, warn, error)&quot;)&#10;&#10;&#9;// Server-specific flags&#10;&#9;rootCmd.Flags().String(&quot;nats-url&quot;, &quot;nats://localhost:4222&quot;, &quot;NATS server URL&quot;)&#10;&#9;rootCmd.Flags().String(&quot;listen-addr&quot;, &quot;:8080&quot;, &quot;Address to listen on for incoming connections&quot;)&#10;&#10;&#9;// Bind flags to viper&#10;&#9;viper.BindPFlag(&quot;nats.url&quot;, rootCmd.Flags().Lookup(&quot;nats-url&quot;))&#10;&#9;viper.BindPFlag(&quot;server.listen_addr&quot;, rootCmd.Flags().Lookup(&quot;listen-addr&quot;))&#10;&#9;viper.BindPFlag(&quot;log.level&quot;, rootCmd.PersistentFlags().Lookup(&quot;log-level&quot;))&#10;}&#10;&#10;func initConfig() {&#10;&#9;if cfgFile != &quot;&quot; {&#10;&#9;&#9;viper.SetConfigFile(cfgFile)&#10;&#9;} else {&#10;&#9;&#9;viper.AddConfigPath(&quot;.&quot;)&#10;&#9;&#9;viper.AddConfigPath(&quot;$HOME&quot;)&#10;&#9;&#9;viper.SetConfigName(&quot;.nats-proxy-server&quot;)&#10;&#9;}&#10;&#10;&#9;viper.AutomaticEnv()&#10;&#10;&#9;// Map environment variables to viper keys&#10;&#9;viper.BindEnv(&quot;nats.url&quot;, &quot;NATS_URL&quot;)&#10;&#9;viper.BindEnv(&quot;log.level&quot;, &quot;LOG_LEVEL&quot;)&#10;&#10;&#9;if err := viper.ReadInConfig(); err == nil {&#10;&#9;&#9;fmt.Println(&quot;Using config file:&quot;, viper.ConfigFileUsed())&#10;&#9;}&#10;}&#10;&#10;func runServer(cmd *cobra.Command, args []string) error {&#10;&#9;// Setup logging&#10;&#9;level, err := logrus.ParseLevel(viper.GetString(&quot;log.level&quot;))&#10;&#9;if err != nil {&#10;&#9;&#9;return fmt.Errorf(&quot;invalid log level: %w&quot;, err)&#10;&#9;}&#10;&#9;logrus.SetLevel(level)&#10;&#9;logrus.SetFormatter(&amp;logrus.TextFormatter{&#10;&#9;&#9;FullTimestamp: true,&#10;&#9;})&#10;&#10;&#9;logger := logrus.WithField(&quot;component&quot;, &quot;server&quot;)&#10;&#9;logger.Info(&quot;Starting NATS TCP Proxy Server&quot;)&#10;&#10;&#9;// Server now receives remote host/port from client messages&#10;&#10;&#9;// Initialize components&#10;&#9;connectionRepo := repositories.NewInMemoryConnectionRepository()&#10;&#9;natsTransport := transport.NewNATSTransport(logger)&#10;&#10;&#9;// Connect to NATS&#10;&#9;natsConfig := &amp;transport.NATSConfig{&#10;&#9;&#9;URL:     viper.GetString(&quot;nats.url&quot;),&#10;&#9;&#9;Timeout: 30 * time.Second,&#10;&#9;}&#10;&#10;&#9;ctx := context.Background()&#10;&#9;if err := natsTransport.Connect(ctx, natsConfig); err != nil {&#10;&#9;&#9;return fmt.Errorf(&quot;failed to connect to NATS: %w&quot;, err)&#10;&#9;}&#10;&#9;defer natsTransport.Close()&#10;&#10;&#9;proxyService := services.NewProxyService(connectionRepo, natsTransport, logger)&#10;&#10;&#9;// Handle graceful shutdown&#10;&#9;ctx, cancel := context.WithCancel(context.Background())&#10;&#9;defer cancel()&#10;&#10;&#9;sigChan := make(chan os.Signal, 1)&#10;&#9;signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)&#10;&#10;&#9;// Start listening for proxy requests&#10;&#9;go func() {&#10;&#9;&#9;err := proxyService.HandleNATSProxyRequests(ctx, &quot;proxy.request&quot;)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;logger.WithError(err).Error(&quot;Failed to handle NATS proxy requests&quot;)&#10;&#9;&#9;&#9;cancel() // Stop the application if request handling fails&#10;&#9;&#9;}&#10;&#9;}()&#10;&#10;&#9;logger.Info(&quot;Server started successfully - listening for NATS messages&quot;)&#10;&#10;&#9;// Wait for shutdown signal&#10;&#9;&lt;-sigChan&#10;&#9;logger.Info(&quot;Shutting down server...&quot;)&#10;&#9;cancel() // Cancel context to stop services&#10;&#10;&#9;// Give services time to gracefully shutdown&#10;&#9;time.Sleep(2 * time.Second)&#10;&#10;&#9;logger.Info(&quot;Server shutdown complete&quot;)&#10;&#10;&#9;return nil&#10;}&#10;" />
              <option name="updatedContent" value="package main&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;os&quot;&#10;&#9;&quot;os/signal&quot;&#10;&#9;&quot;syscall&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;github.com/igorrius/tcp-sproxy/internal/domain/services&quot;&#10;&#9;&quot;github.com/igorrius/tcp-sproxy/internal/infrastructure/repositories&quot;&#10;&#9;&quot;github.com/igorrius/tcp-sproxy/internal/infrastructure/transport&quot;&#10;&#9;&quot;github.com/sirupsen/logrus&quot;&#10;&#9;&quot;github.com/spf13/cobra&quot;&#10;&#9;&quot;github.com/spf13/viper&quot;&#10;)&#10;&#10;var (&#10;&#9;cfgFile  string&#10;&#9;logLevel string&#10;)&#10;&#10;func main() {&#10;&#9;Execute()&#10;}&#10;&#10;var rootCmd = &amp;cobra.Command{&#10;&#9;Use:   &quot;nats-proxy-server&quot;,&#10;&#9;Short: &quot;NATS TCP Proxy Server&quot;,&#10;&#9;Long: `A TCP proxy server that uses NATS as the transport layer.&#10;This server accepts connections and forwards them to a remote host using NATS.`,&#10;&#9;RunE: runServer,&#10;}&#10;&#10;func Execute() {&#10;&#9;if err := rootCmd.Execute(); err != nil {&#10;&#9;&#9;fmt.Fprintln(os.Stderr, err)&#10;&#9;&#9;os.Exit(1)&#10;&#9;}&#10;}&#10;&#10;func init() {&#10;&#9;cobra.OnInitialize(initConfig)&#10;&#10;&#9;rootCmd.PersistentFlags().StringVar(&amp;cfgFile, &quot;config&quot;, &quot;&quot;, &quot;config file (default is $HOME/.nats-proxy-server.yaml)&quot;)&#10;&#9;rootCmd.PersistentFlags().StringVar(&amp;logLevel, &quot;log-level&quot;, &quot;info&quot;, &quot;log level (debug, info, warn, error)&quot;)&#10;&#10;&#9;// Server-specific flags&#10;&#9;rootCmd.Flags().String(&quot;nats-url&quot;, &quot;nats://localhost:4222&quot;, &quot;NATS server URL&quot;)&#10;&#9;rootCmd.Flags().String(&quot;listen-addr&quot;, &quot;:8080&quot;, &quot;Address to listen on for incoming connections&quot;)&#10;&#10;&#9;// Bind flags to viper&#10;&#9;viper.BindPFlag(&quot;nats.url&quot;, rootCmd.Flags().Lookup(&quot;nats-url&quot;))&#10;&#9;viper.BindPFlag(&quot;server.listen_addr&quot;, rootCmd.Flags().Lookup(&quot;listen-addr&quot;))&#10;&#9;viper.BindPFlag(&quot;log.level&quot;, rootCmd.PersistentFlags().Lookup(&quot;log-level&quot;))&#10;}&#10;&#10;func initConfig() {&#10;&#9;if cfgFile != &quot;&quot; {&#10;&#9;&#9;viper.SetConfigFile(cfgFile)&#10;&#9;} else {&#10;&#9;&#9;viper.AddConfigPath(&quot;.&quot;)&#10;&#9;&#9;viper.AddConfigPath(&quot;$HOME&quot;)&#10;&#9;&#9;viper.SetConfigName(&quot;.nats-proxy-server&quot;)&#10;&#9;}&#10;&#10;&#9;viper.AutomaticEnv()&#10;&#10;&#9;// Map environment variables to viper keys&#10;&#9;viper.BindEnv(&quot;nats.url&quot;, &quot;NATS_URL&quot;)&#10;&#9;viper.BindEnv(&quot;log.level&quot;, &quot;LOG_LEVEL&quot;)&#10;&#10;&#9;if err := viper.ReadInConfig(); err == nil {&#10;&#9;&#9;fmt.Println(&quot;Using config file:&quot;, viper.ConfigFileUsed())&#10;&#9;}&#10;}&#10;&#10;func runServer(cmd *cobra.Command, args []string) error {&#10;&#9;// Setup logging&#10;&#9;level, err := logrus.ParseLevel(viper.GetString(&quot;log.level&quot;))&#10;&#9;if err != nil {&#10;&#9;&#9;return fmt.Errorf(&quot;invalid log level: %w&quot;, err)&#10;&#9;}&#10;&#9;logrus.SetLevel(level)&#10;&#9;logrus.SetFormatter(&amp;logrus.TextFormatter{&#10;&#9;&#9;FullTimestamp: true,&#10;&#9;})&#10;&#10;&#9;logger := logrus.WithField(&quot;component&quot;, &quot;server&quot;)&#10;&#9;logger.Info(&quot;Starting NATS TCP Proxy Server&quot;)&#10;&#10;&#9;// Server now receives remote host/port from client messages&#10;&#10;&#9;// Initialize components&#10;&#9;connectionRepo := repositories.NewInMemoryConnectionRepository()&#10;&#9;natsTransport := transport.NewNATSTransport(logger)&#10;&#10;&#9;// Connect to NATS&#10;&#9;natsConfig := &amp;transport.NATSConfig{&#10;&#9;&#9;URL:     viper.GetString(&quot;nats.url&quot;),&#10;&#9;&#9;Timeout: 30 * time.Second,&#10;&#9;}&#10;&#10;&#9;if err := natsTransport.Connect(context.Background(), natsConfig); err != nil {&#10;&#9;&#9;return fmt.Errorf(&quot;failed to connect to NATS: %w&quot;, err)&#10;&#9;}&#10;&#9;defer natsTransport.Close()&#10;&#10;&#9;proxyService := services.NewProxyService(connectionRepo, natsTransport, logger)&#10;&#10;&#9;// Handle graceful shutdown&#10;&#9;ctx, cancel := context.WithCancel(context.Background())&#10;&#9;defer cancel()&#10;&#10;&#9;sigChan := make(chan os.Signal, 1)&#10;&#9;signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)&#10;&#10;&#9;// Start listening for proxy requests&#10;&#9;go func() {&#10;&#9;&#9;err := proxyService.HandleNATSProxyRequests(ctx, &quot;proxy.request&quot;)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;logger.WithError(err).Error(&quot;Failed to handle NATS proxy requests&quot;)&#10;&#9;&#9;&#9;cancel() // Stop the application if request handling fails&#10;&#9;&#9;}&#10;&#9;}()&#10;&#10;&#9;logger.Info(&quot;Server started successfully - listening for NATS messages&quot;)&#10;&#10;&#9;// Wait for shutdown signal&#10;&#9;&lt;-sigChan&#10;&#9;logger.Info(&quot;Shutting down server...&quot;)&#10;&#9;cancel() // Cancel context to stop services&#10;&#10;&#9;// Give services time to gracefully shutdown&#10;&#9;time.Sleep(2 * time.Second)&#10;&#10;&#9;logger.Info(&quot;Server shutdown complete&quot;)&#10;&#10;&#9;return nil&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/docs/architecture.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/docs/architecture.md" />
              <option name="originalContent" value="# NATS TCP Proxy - Architecture Documentation&#10;&#10;## Overview&#10;&#10;The NATS TCP Proxy is a high-performance TCP proxy that uses NATS (Neural Autonomic Transport System) as the transport layer for proxying TCP connections between client and server. The project follows Domain-Driven Design (DDD) methodology with a clean architecture approach.&#10;&#10;## Architecture Layers&#10;&#10;### 1. Domain Layer (`internal/domain/`)&#10;&#10;The domain layer contains the core business logic and is independent of external concerns.&#10;&#10;#### Entities (`internal/domain/entities/`)&#10;- **Connection**: Represents a TCP connection between client and server&#10;  - Properties: ID, ClientAddr, ServerAddr, CreatedAt, LastActivity, Status&#10;  - Methods: UpdateActivity(), SetStatus(), IsActive(), Close(), etc.&#10;&#10;#### Value Objects (`internal/domain/valueobjects/`)&#10;- **ConnectionID**: Unique identifier for connections&#10;  - Immutable and self-validating&#10;  - Methods: String(), Equals(), IsZero()&#10;&#10;#### Domain Services (`internal/domain/services/`)&#10;- **ProxyService**: Core business logic for handling proxy connections&#10;  - Methods: ProxyConnection(), GetConnectionStats(), CloseConnection()&#10;  - Handles bidirectional data flow between client and remote server&#10;&#10;#### Repositories (`internal/domain/repositories/`)&#10;- **ConnectionRepository**: Interface for connection persistence&#10;  - Methods: Store(), GetByID(), GetActive(), GetAll(), Update(), Delete(), Cleanup()&#10;&#10;### 2. Application Layer (`internal/application/`)&#10;&#10;The application layer orchestrates domain objects and implements use cases.&#10;&#10;#### Use Cases (`internal/application/usecases/`)&#10;- **ProxyUseCase**: Application logic for proxy operations&#10;  - Methods: HandleNewConnection(), GetConnectionStats(), CleanupOldConnections()&#10;  - Coordinates between domain services and infrastructure&#10;&#10;### 3. Infrastructure Layer (`internal/infrastructure/`)&#10;&#10;The infrastructure layer handles external concerns like transport and persistence.&#10;&#10;#### Transport (`internal/infrastructure/transport/`)&#10;- **NATSTransport**: NATS implementation of the abstract transport interface&#10;  - Handles connection to NATS server&#10;  - Manages message publishing/subscribing&#10;  - Implements request-reply pattern&#10;&#10;#### Repositories (`internal/infrastructure/repositories/`)&#10;- **InMemoryConnectionRepository**: In-memory implementation of ConnectionRepository&#10;  - Thread-safe connection storage&#10;  - Provides statistics and cleanup functionality&#10;&#10;### 4. Interface Layer (`cmd/`)&#10;&#10;The interface layer handles user interaction and external APIs.&#10;&#10;#### CLI Commands (`cmd/client/` and `cmd/server/`)&#10;- **Client**: Listens on local port and forwards connections through NATS&#10;- **Server**: Receives NATS messages and forwards to remote server&#10;- Both use Cobra for CLI framework and Viper for configuration&#10;&#10;## Transport Layer&#10;&#10;### Abstract Transport Interface (`pkg/transport/`)&#10;&#10;```go&#10;type Transport interface {&#10;    Connect(ctx context.Context, config interface{}) error&#10;    Disconnect(ctx context.Context) error&#10;    Send(ctx context.Context, subject string, message *Message) error&#10;    Subscribe(ctx context.Context, subject string) (&lt;-chan *Message, error)&#10;    Request(ctx context.Context, subject string, message *Message) (*Message, error)&#10;    Publish(ctx context.Context, subject string, message *Message) error&#10;    Close() error&#10;    IsConnected() bool&#10;}&#10;```&#10;&#10;### NATS Implementation&#10;&#10;The NATS transport implementation provides:&#10;- **Connection Management**: Automatic reconnection and error handling&#10;- **Message Serialization**: JSON-based message format&#10;- **Subject-based Routing**: Uses NATS subjects for message routing&#10;- **Request-Reply Pattern**: Supports synchronous request-response&#10;- **Publish-Subscribe**: Supports asynchronous message broadcasting&#10;&#10;## Data Flow&#10;&#10;### Client-Side Flow&#10;&#10;1. **Connection Acceptance**: Client listens on local port&#10;2. **NATS Connection**: Establishes connection to NATS server&#10;3. **Message Forwarding**: Reads from client connection and publishes to NATS with remote target info&#10;4. **Response Handling**: Subscribes to response subject and forwards to client&#10;&#10;### Server-Side Flow&#10;&#10;1. **NATS Subscription**: Subscribes to request subjects&#10;2. **Worker Creation**: Creates separate worker for each connection&#10;3. **Remote Connection**: Worker establishes connection to client-specified remote target&#10;4. **Data Forwarding**: Forwards data between NATS and remote server&#10;5. **Response Publishing**: Publishes responses back to NATS&#10;&#10;### Message Format&#10;&#10;```json&#10;{&#10;  &quot;id&quot;: &quot;connection_id&quot;,&#10;  &quot;data&quot;: &quot;base64_encoded_data&quot;,&#10;  &quot;metadata&quot;: {&#10;    &quot;response_subject&quot;: &quot;proxy.response.conn_id&quot;,&#10;    &quot;client_addr&quot;: &quot;127.0.0.1:54321&quot;,&#10;    &quot;remote_host&quot;: &quot;localhost&quot;,&#10;    &quot;remote_port&quot;: &quot;6379&quot;&#10;  }&#10;}&#10;```&#10;&#10;## Configuration&#10;&#10;### Server Configuration&#10;&#10;- `--nats-url`: NATS server URL (default: nats://localhost:4222)&#10;- `--remote-host`: Target remote host&#10;- `--remote-port`: Target remote port&#10;- `--listen-addr`: Address to listen on (default: :8080)&#10;- `--log-level`: Log level (debug, info, warn, error)&#10;&#10;### Client Configuration&#10;&#10;- `--nats-url`: NATS server URL (default: nats://localhost:4222)&#10;- `--local-port`: Local port to listen on&#10;- `--listen-addr`: Local address to listen on (default: localhost)&#10;- `--log-level`: Log level (debug, info, warn, error)&#10;&#10;## Error Handling&#10;&#10;### Connection Errors&#10;- **NATS Connection**: Automatic reconnection with exponential backoff&#10;- **Remote Connection**: Timeout handling and graceful degradation&#10;- **Client Connection**: Proper cleanup and resource management&#10;&#10;### Message Errors&#10;- **Serialization**: JSON marshaling/unmarshaling error handling&#10;- **Transport**: Network timeout and retry logic&#10;- **Validation**: Input validation and sanitization&#10;&#10;## Performance Considerations&#10;&#10;### Connection Management&#10;- **Connection Pooling**: Reuses connections where possible&#10;- **Timeout Handling**: 30-second timeouts prevent hanging connections&#10;- **Buffer Management**: 32KB buffers for efficient data transfer&#10;&#10;### Memory Management&#10;- **Garbage Collection**: Proper cleanup of closed connections&#10;- **Memory Leaks**: Regular cleanup of old connections&#10;- **Resource Limits**: Configurable limits for concurrent connections&#10;&#10;### Scalability&#10;- **Horizontal Scaling**: Multiple clients can connect to same server&#10;- **Load Balancing**: NATS can distribute load across multiple servers&#10;- **High Availability**: NATS clustering for fault tolerance&#10;&#10;## Security Considerations&#10;&#10;### Network Security&#10;- **TLS Support**: NATS supports TLS for encrypted communication&#10;- **Authentication**: NATS authentication and authorization&#10;- **Firewall**: Proper firewall configuration for proxy ports&#10;&#10;### Data Security&#10;- **Message Encryption**: Optional message encryption&#10;- **Access Control**: Port and IP-based access control&#10;- **Audit Logging**: Comprehensive logging for security auditing&#10;&#10;## Monitoring and Observability&#10;&#10;### Metrics&#10;- **Connection Count**: Active, closed, and error connections&#10;- **Data Transfer**: Bytes transferred in each direction&#10;- **Response Times**: Connection establishment and data transfer times&#10;&#10;### Logging&#10;- **Structured Logging**: JSON-formatted logs with correlation IDs&#10;- **Log Levels**: Configurable log levels for different environments&#10;- **Log Rotation**: Automatic log rotation and cleanup&#10;&#10;### Health Checks&#10;- **NATS Connectivity**: Regular health checks for NATS connection&#10;- **Remote Connectivity**: Health checks for remote server connection&#10;- **Resource Usage**: Memory and CPU usage monitoring&#10;&#10;## Deployment&#10;&#10;### Local Development&#10;```bash&#10;# Build the project&#10;make build&#10;&#10;# Start server&#10;./bin/server --nats-url nats://localhost:4222&#10;&#10;# Start client&#10;./bin/client --local-port 6380 --remote-host localhost --remote-port 6379&#10;```&#10;&#10;### Production Deployment&#10;1. **Containerization**: Docker images for easy deployment&#10;2. **Orchestration**: Kubernetes manifests for container orchestration&#10;3. **Service Discovery**: Integration with service discovery systems&#10;4. **Configuration Management**: Environment-based configuration&#10;&#10;### Docker Deployment&#10;&#10;The server can be deployed using Docker with the provided configuration:&#10;&#10;```bash&#10;# Build and run with Docker&#10;./scripts/docker-server.sh build&#10;./scripts/docker-server.sh run&#10;&#10;# Or use Docker Compose for full stack&#10;./scripts/docker-server.sh compose&#10;```&#10;&#10;**Docker Features:**&#10;- **Multi-stage build** for optimized image size&#10;- **Non-root user** for security&#10;- **Health checks** for monitoring&#10;- **Environment variables** for configuration&#10;- **Docker Compose** for complete stack deployment&#10;&#10;### High Availability&#10;1. **NATS Clustering**: Multiple NATS servers for redundancy&#10;2. **Load Balancing**: Multiple proxy servers behind load balancer&#10;3. **Health Checks**: Automated health checks and failover&#10;4. **Backup and Recovery**: Regular backups and disaster recovery&#10;&#10;## Testing Strategy&#10;&#10;### Unit Tests&#10;- **Domain Logic**: Tests for entities, value objects, and domain services&#10;- **Repository Tests**: Tests for data access layer&#10;- **Transport Tests**: Tests for NATS transport implementation&#10;&#10;### Integration Tests&#10;- **End-to-End**: Full proxy functionality tests&#10;- **NATS Integration**: Tests with real NATS server&#10;- **Performance Tests**: Load testing and performance benchmarks&#10;&#10;### Acceptance Tests&#10;- **Redis Proxy**: Complete Redis proxy scenario&#10;- **Multiple Connections**: Tests with multiple concurrent connections&#10;- **Error Scenarios**: Tests for various error conditions&#10;&#10;## Future Enhancements&#10;&#10;### Planned Features&#10;1. **Multiple Transport Support**: gRPC, WebSocket, and other transport layers&#10;2. **Protocol Support**: HTTP, HTTPS, and other protocols&#10;3. **Advanced Routing**: Content-based routing and load balancing&#10;4. **Metrics Integration**: Prometheus and Grafana integration&#10;5. **API Gateway**: REST API for management and monitoring&#10;&#10;### Scalability Improvements&#10;1. **Connection Multiplexing**: Multiple connections over single NATS connection&#10;2. **Compression**: Data compression for better performance&#10;3. **Caching**: Response caching for frequently accessed data&#10;4. **Rate Limiting**: Configurable rate limiting per connection&#10;&#10;### Security Enhancements&#10;1. **mTLS**: Mutual TLS authentication&#10;2. **OAuth2**: OAuth2 integration for authentication&#10;3. **RBAC**: Role-based access control&#10;4. **Audit Trail**: Comprehensive audit logging&#10;" />
              <option name="updatedContent" value="# NATS TCP Proxy - Architecture Documentation&#10;&#10;## Overview&#10;&#10;The NATS TCP Proxy is a high-performance TCP proxy that uses NATS (Neural Autonomic Transport System) as the transport layer for proxying TCP connections between client and server. The project follows Domain-Driven Design (DDD) methodology with a clean architecture approach.&#10;&#10;## Architecture Layers&#10;&#10;### 1. Domain Layer (`internal/domain/`)&#10;&#10;The domain layer contains the core business logic and is independent of external concerns.&#10;&#10;#### Entities (`internal/domain/entities/`)&#10;- **Connection**: Represents a TCP connection between client and server&#10;  - Properties: ID, ClientAddr, ServerAddr, CreatedAt, LastActivity, Status&#10;  - Methods: UpdateActivity(), SetStatus(), IsActive(), Close(), etc.&#10;&#10;#### Value Objects (`internal/domain/valueobjects/`)&#10;- **ConnectionID**: Unique identifier for connections&#10;  - Immutable and self-validating&#10;  - Methods: String(), Equals(), IsZero()&#10;&#10;#### Domain Services (`internal/domain/services/`)&#10;- **ProxyService**: Core business logic for handling proxy connections&#10;  - Methods: ProxyConnection(), GetConnectionStats(), CloseConnection()&#10;  - Handles bidirectional data flow between client and remote server&#10;&#10;#### Repositories (`internal/domain/repositories/`)&#10;- **ConnectionRepository**: Interface for connection persistence&#10;  - Methods: Store(), GetByID(), GetActive(), GetAll(), Update(), Delete(), Cleanup()&#10;&#10;### 2. Application Layer (`internal/application/`)&#10;&#10;The application layer orchestrates domain objects and implements use cases.&#10;&#10;#### Use Cases (`internal/application/usecases/`)&#10;- **ProxyUseCase**: Application logic for proxy operations&#10;  - Methods: HandleNewConnection(), GetConnectionStats(), CleanupOldConnections()&#10;  - Coordinates between domain services and infrastructure&#10;&#10;### 3. Infrastructure Layer (`internal/infrastructure/`)&#10;&#10;The infrastructure layer handles external concerns like transport and persistence.&#10;&#10;#### Transport (`internal/infrastructure/transport/`)&#10;- **NATSTransport**: NATS implementation of the abstract transport interface&#10;  - Handles connection to NATS server&#10;  - Manages message publishing/subscribing&#10;  - Implements request-reply pattern&#10;&#10;#### Repositories (`internal/infrastructure/repositories/`)&#10;- **InMemoryConnectionRepository**: In-memory implementation of ConnectionRepository&#10;  - Thread-safe connection storage&#10;  - Provides statistics and cleanup functionality&#10;&#10;### 4. Interface Layer (`cmd/`)&#10;&#10;The interface layer handles user interaction and external APIs.&#10;&#10;#### CLI Commands (`cmd/client/` and `cmd/server/`)&#10;- **Client**: Listens on local port and forwards connections through NATS&#10;- **Server**: Receives NATS messages and forwards to remote server&#10;- Both use Cobra for CLI framework and Viper for configuration&#10;&#10;## Transport Layer&#10;&#10;### Abstract Transport Interface (`pkg/transport/`)&#10;&#10;```go&#10;type Transport interface {&#10;    Connect(ctx context.Context, config interface{}) error&#10;    Disconnect(ctx context.Context) error&#10;    Send(ctx context.Context, subject string, message *Message) error&#10;    Subscribe(ctx context.Context, subject string) (&lt;-chan *Message, error)&#10;    Request(ctx context.Context, subject string, message *Message) (*Message, error)&#10;    Publish(ctx context.Context, subject string, message *Message) error&#10;    Close() error&#10;    IsConnected() bool&#10;}&#10;```&#10;&#10;### NATS Implementation&#10;&#10;The NATS transport implementation provides:&#10;- **Connection Management**: Automatic reconnection and error handling&#10;- **Message Serialization**: JSON-based message format&#10;- **Subject-based Routing**: Uses NATS subjects for message routing&#10;- **Request-Reply Pattern**: Supports synchronous request-response&#10;- **Publish-Subscribe**: Supports asynchronous message broadcasting&#10;&#10;## Data Flow&#10;&#10;### Client-Side Flow&#10;&#10;1. **Connection Acceptance**: Client listens on local port&#10;2. **NATS Connection**: Establishes connection to NATS server&#10;3. **Message Forwarding**: Reads from client connection and publishes to NATS with remote target info&#10;4. **Response Handling**: Subscribes to response subject and forwards to client&#10;&#10;### Server-Side Flow&#10;&#10;1. **NATS Subscription**: Subscribes to request subjects&#10;2. **Worker Creation**: Creates separate worker for each connection&#10;3. **Remote Connection**: Worker establishes connection to client-specified remote target&#10;4. **Data Forwarding**: Forwards data between NATS and remote server&#10;5. **Response Publishing**: Publishes responses back to NATS&#10;&#10;### Message Format&#10;&#10;```json&#10;{&#10;  &quot;id&quot;: &quot;connection_id&quot;,&#10;  &quot;data&quot;: &quot;base64_encoded_data&quot;,&#10;  &quot;metadata&quot;: {&#10;    &quot;response_subject&quot;: &quot;proxy.response.conn_id&quot;,&#10;    &quot;client_addr&quot;: &quot;127.0.0.1:54321&quot;,&#10;    &quot;remote_host&quot;: &quot;localhost&quot;,&#10;    &quot;remote_port&quot;: &quot;6379&quot;&#10;  }&#10;}&#10;```&#10;&#10;## Configuration&#10;&#10;### Server Configuration&#10;&#10;- `--nats-url`: NATS server URL (default: nats://localhost:4222)&#10;- `--remote-host`: Target remote host&#10;- `--remote-port`: Target remote port&#10;- `--listen-addr`: Address to listen on (default: :8080)&#10;- `--log-level`: Log level (debug, info, warn, error)&#10;&#10;### Client Configuration&#10;&#10;- `--nats-url`: NATS server URL (default: nats://localhost:4222)&#10;- `--local-port`: Local port to listen on&#10;- `--listen-addr`: Local address to listen on (default: localhost)&#10;- `--log-level`: Log level (debug, info, warn, error)&#10;&#10;## Error Handling&#10;&#10;### Connection Errors&#10;- **NATS Connection**: Automatic reconnection with exponential backoff&#10;- **Remote Connection**: Timeout handling and graceful degradation&#10;- **Client Connection**: Proper cleanup and resource management&#10;&#10;### Message Errors&#10;- **Serialization**: JSON marshaling/unmarshaling error handling&#10;- **Transport**: Network timeout and retry logic&#10;- **Validation**: Input validation and sanitization&#10;&#10;## Performance Considerations&#10;&#10;### Connection Management&#10;- **Connection Pooling**: Reuses connections where possible&#10;- **Timeout Handling**: 30-second timeouts prevent hanging connections&#10;- **Buffer Management**: 32KB buffers for efficient data transfer&#10;&#10;### Memory Management&#10;- **Garbage Collection**: Proper cleanup of closed connections&#10;- **Memory Leaks**: Regular cleanup of old connections&#10;- **Resource Limits**: Configurable limits for concurrent connections&#10;&#10;### Scalability&#10;- **Horizontal Scaling**: Multiple clients can connect to same server&#10;- **Load Balancing**: NATS can distribute load across multiple servers&#10;- **High Availability**: NATS clustering for fault tolerance&#10;&#10;## Security Considerations&#10;&#10;### Network Security&#10;- **TLS Support**: NATS supports TLS for encrypted communication&#10;- **Authentication**: NATS authentication and authorization&#10;- **Firewall**: Proper firewall configuration for proxy ports&#10;&#10;### Data Security&#10;- **Message Encryption**: Optional message encryption&#10;- **Access Control**: Port and IP-based access control&#10;- **Audit Logging**: Comprehensive logging for security auditing&#10;&#10;## Monitoring and Observability&#10;&#10;### Metrics&#10;- **Connection Count**: Active, closed, and error connections&#10;- **Data Transfer**: Bytes transferred in each direction&#10;- **Response Times**: Connection establishment and data transfer times&#10;&#10;### Logging&#10;- **Structured Logging**: JSON-formatted logs with correlation IDs&#10;- **Log Levels**: Configurable log levels for different environments&#10;- **Log Rotation**: Automatic log rotation and cleanup&#10;&#10;### Health Checks&#10;- **NATS Connectivity**: Regular health checks for NATS connection&#10;- **Remote Connectivity**: Health checks for remote server connection&#10;- **Resource Usage**: Memory and CPU usage monitoring&#10;&#10;## Deployment&#10;&#10;### Local Development&#10;```bash&#10;# Build the project&#10;make build&#10;&#10;# Start server&#10;./bin/server --nats-url nats://localhost:4222&#10;&#10;# Start client&#10;./bin/client --local-port 6380 --remote-host localhost --remote-port 6379&#10;```&#10;&#10;### Production Deployment&#10;1. **Containerization**: Docker images for easy deployment&#10;2. **Orchestration**: Kubernetes manifests for container orchestration&#10;3. **Service Discovery**: Integration with service discovery systems&#10;4. **Configuration Management**: Environment-based configuration&#10;&#10;### Docker Deployment&#10;&#10;The server can be deployed using Docker with the provided configuration:&#10;&#10;```bash&#10;# Build and run with Docker&#10;./scripts/docker-server.sh build&#10;./scripts/docker-server.sh run&#10;&#10;# Or use Docker Compose for full stack&#10;./scripts/docker-server.sh compose&#10;```&#10;&#10;**Docker Features:**&#10;- **Multi-stage build** for optimized image size&#10;- **Non-root user** for security&#10;- **Health checks** for monitoring&#10;- **Environment variables** for configuration&#10;- **Docker Compose** for complete stack deployment&#10;&#10;### High Availability&#10;1. **NATS Clustering**: Multiple NATS servers for redundancy&#10;2. **Load Balancing**: Multiple proxy servers behind load balancer&#10;3. **Health Checks**: Automated health checks and failover&#10;4. **Backup and Recovery**: Regular backups and disaster recovery&#10;&#10;## Testing Strategy&#10;&#10;### Unit Tests&#10;- **Domain Logic**: Tests for entities, value objects, and domain services&#10;- **Repository Tests**: Tests for data access layer&#10;- **Transport Tests**: Tests for NATS transport implementation&#10;&#10;### Integration Tests&#10;- **End-to-End**: Full proxy functionality tests&#10;- **NATS Integration**: Tests with real NATS server&#10;- **Performance Tests**: Load testing and performance benchmarks&#10;&#10;### Acceptance Tests&#10;- **Redis Proxy**: Complete Redis proxy scenario&#10;- **Multiple Connections**: Tests with multiple concurrent connections&#10;- **Error Scenarios**: Tests for various error conditions&#10;&#10;## Future Enhancements&#10;&#10;### Planned Features&#10;1. **Multiple Transport Support**: gRPC, WebSocket, and other transport layers&#10;2. **Protocol Support**: HTTP, HTTPS, and other protocols&#10;3. **Advanced Routing**: Content-based routing and load balancing&#10;4. **API Gateway**: REST API for management and monitoring&#10;&#10;### Scalability Improvements&#10;1. **Connection Multiplexing**: Multiple connections over single NATS connection&#10;2. **Compression**: Data compression for better performance&#10;3. **Caching**: Response caching for frequently accessed data&#10;4. **Rate Limiting**: Configurable rate limiting per connection&#10;&#10;### Security Enhancements&#10;1. **mTLS**: Mutual TLS authentication&#10;2. **RBAC**: Role-based access control&#10;3. **Audit Trail**: Comprehensive audit logging" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/integration_tests/build/Dockerfile">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/integration_tests/build/Dockerfile" />
              <option name="originalContent" value="# build stage&#10;FROM golang:1.22-alpine as builder&#10;WORKDIR /app&#10;COPY . .&#10;RUN go build -o /app/cmd/server/server /app/cmd/server/main.go&#10;RUN go build -o /app/cmd/client/client /app/cmd/client/main.go&#10;&#10;# final stage&#10;FROM alpine:latest&#10;WORKDIR /app&#10;COPY --from=builder /app/cmd/server/server /app/server&#10;COPY --from=builder /app/cmd/client/client /app/client&#10;COPY . .&#10;EXPOSE 8080&#10;EXPOSE 8081&#10;&#10;" />
              <option name="updatedContent" value="# build stage&#10;FROM golang:1.24-alpine as builder&#10;WORKDIR /app&#10;COPY . .&#10;RUN go build -o /app/cmd/server/server /app/cmd/server/main.go&#10;RUN go build -o /app/cmd/client/client /app/cmd/client/main.go&#10;&#10;# final stage&#10;FROM alpine:latest&#10;RUN apk add --no-cache netcat-openbsd&#10;WORKDIR /app&#10;COPY --from=builder /app/cmd/server/server /app/server&#10;COPY --from=builder /app/cmd/client/client /app/client&#10;COPY . .&#10;EXPOSE 8080&#10;EXPOSE 8081" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/integration_tests/build/Dockerfile.test_runner">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/integration_tests/build/Dockerfile.test_runner" />
              <option name="originalContent" value="FROM golang:1.22-alpine&#10;&#10;WORKDIR /app&#10;&#10;COPY go.mod go.sum ./&#10;RUN go mod download&#10;&#10;COPY . .&#10;&#10;CMD [&quot;go&quot;, &quot;test&quot;, &quot;-v&quot;, &quot;./integration_tests/...&quot;]&#10;&#10;" />
              <option name="updatedContent" value="FROM golang:1.24-alpine&#10;&#10;WORKDIR /app&#10;&#10;COPY go.mod go.sum ./&#10;RUN go mod download&#10;&#10;COPY . .&#10;&#10;CMD [&quot;go&quot;, &quot;test&quot;, &quot;-v&quot;, &quot;./integration_tests/...&quot;]" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/integration_tests/docker-compose.yml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/integration_tests/docker-compose.yml" />
              <option name="originalContent" value="version: '3.8'&#10;services:&#10;  redis:&#10;    image: redis:7.0-alpine&#10;    ports:&#10;      - &quot;6379:6379&quot;&#10;&#10;  nats:&#10;    image: nats:2.9-alpine&#10;    ports:&#10;      - &quot;4222:4222&quot;&#10;&#10;  proxy-server:&#10;    build:&#10;      context: ..&#10;      dockerfile: integration_tests/build/Dockerfile&#10;    depends_on:&#10;      - nats&#10;    environment:&#10;      - NATS_URL=nats://nats:4222&#10;      - LISTEN_ADDR=:8080&#10;      - PROXY_ADDR=:8081&#10;    ports:&#10;      - &quot;8080:8080&quot;&#10;      - &quot;8081:8081&quot;&#10;    command: /app/server&#10;&#10;  proxy-client:&#10;    build:&#10;      context: ..&#10;      dockerfile: integration_tests/build/Dockerfile&#10;    depends_on:&#10;      - nats&#10;      - proxy-server&#10;    environment:&#10;      - NATS_URL=nats://nats:4222&#10;      - LISTEN_ADDR=0.0.0.0:8082&#10;      - PROXY_ADDR=proxy-server:8081&#10;      - REMOTE_ADDR=redis:6379&#10;    ports:&#10;      - &quot;8082:8082&quot;&#10;    command: /app/client&#10;&#10;  test-runner:&#10;    build:&#10;      context: ..&#10;      dockerfile: integration_tests/build/Dockerfile.test_runner&#10;    depends_on:&#10;      - proxy-client&#10;      - redis&#10;    environment:&#10;      - NATS_URL=nats://nats:4222&#10;      - LISTEN_ADDR=0.0.0.0:8082&#10;      - PROXY_ADDR=proxy-server:8081&#10;      - REMOTE_ADDR=redis:6379&#10;    command: sh -c &quot;sleep 5 &amp;&amp; go test -v ./integration_tests/...&quot;&#10;" />
              <option name="updatedContent" value="version: '3.8'&#10;services:&#10;  redis:&#10;    image: redis:7.0-alpine&#10;    ports:&#10;      - &quot;6379:6379&quot;&#10;&#10;  nats:&#10;    image: nats:2.9-alpine&#10;    ports:&#10;      - &quot;4222:4222&quot;&#10;&#10;  proxy-server:&#10;    build:&#10;      context: ..&#10;      dockerfile: integration_tests/build/Dockerfile&#10;    depends_on:&#10;      - nats&#10;    environment:&#10;      - NATS_URL=nats://nats:4222&#10;      - LISTEN_ADDR=:8080&#10;      - PROXY_ADDR=:8081&#10;    ports:&#10;      - &quot;8080:8080&quot;&#10;      - &quot;8081:8081&quot;&#10;    command: /app/server&#10;&#10;  proxy-client:&#10;    build:&#10;      context: ..&#10;      dockerfile: integration_tests/build/Dockerfile&#10;    depends_on:&#10;      - nats&#10;      - proxy-server&#10;    environment:&#10;      - NATS_URL=nats://nats:4222&#10;      - LISTEN_ADDR=0.0.0.0:8082&#10;      - PROXY_ADDR=proxy-server:8081&#10;      - REMOTE_ADDR=redis:6379&#10;    ports:&#10;      - &quot;8082:8082&quot;&#10;    command: /app/client&#10;&#10;  test-runner:&#10;    build:&#10;      context: ..&#10;      dockerfile: integration_tests/build/Dockerfile.test_runner&#10;    depends_on:&#10;      - proxy-client&#10;      - redis&#10;    environment:&#10;      - NATS_URL=nats://nats:4222&#10;      - LISTEN_ADDR=0.0.0.0:8082&#10;      - PROXY_ADDR=proxy-server:8081&#10;      - REMOTE_ADDR=redis:6379&#10;    command: sh -c &quot;sleep 10 &amp;&amp; go test -v ./integration_tests/...&quot;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/integration_tests/redis_test.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/integration_tests/redis_test.go" />
              <option name="originalContent" value="package integration_tests&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;testing&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;github.com/go-redis/redis/v8&quot;&#10;&#9;&quot;github.com/stretchr/testify/require&quot;&#10;)&#10;&#10;func TestRedisProxy(t *testing.T) {&#10;&#9;ctx := context.Background()&#10;&#10;&#9;rdb := redis.NewClient(&amp;redis.Options{&#10;&#9;&#9;Addr: &quot;localhost:8082&quot;,&#10;&#9;})&#10;&#10;&#9;// Wait for the proxy to be ready&#10;&#9;time.Sleep(5 * time.Second)&#10;&#10;&#9;_, err := rdb.Ping(ctx).Result()&#10;&#9;require.NoError(t, err)&#10;&#10;&#9;err = rdb.Set(ctx, &quot;key&quot;, &quot;value&quot;, 0).Err()&#10;&#9;require.NoError(t, err)&#10;&#10;&#9;val, err := rdb.Get(ctx, &quot;key&quot;).Result()&#10;&#9;require.NoError(t, err)&#10;&#9;require.Equal(t, &quot;value&quot;, val)&#10;}&#10;" />
              <option name="updatedContent" value="package integration_tests&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;testing&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;github.com/go-redis/redis/v8&quot;&#10;&#9;&quot;github.com/stretchr/testify/require&quot;&#10;)&#10;&#10;func TestRedisProxy(t *testing.T) {&#10;&#9;ctx := context.Background()&#10;&#10;&#9;rdb := redis.NewClient(&amp;redis.Options{&#10;&#9;&#9;Addr:        &quot;proxy-client:8082&quot;,&#10;&#9;&#9;ReadTimeout: 30 * time.Second,&#10;&#9;})&#10;&#10;&#9;// Wait for the proxy to be ready&#10;&#9;time.Sleep(5 * time.Second)&#10;&#10;&#9;_, err := rdb.Ping(ctx).Result()&#10;&#9;require.NoError(t, err)&#10;&#10;&#9;err = rdb.Set(ctx, &quot;key&quot;, &quot;value&quot;, 0).Err()&#10;&#9;require.NoError(t, err)&#10;&#10;&#9;val, err := rdb.Get(ctx, &quot;key&quot;).Result()&#10;&#9;require.NoError(t, err)&#10;&#9;require.Equal(t, &quot;value&quot;, val)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/domain/services/proxy_service.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/domain/services/proxy_service.go" />
              <option name="originalContent" value="package services&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;io&quot;&#10;&#9;&quot;net&quot;&#10;&#9;&quot;strconv&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;github.com/igorrius/tcp-sproxy/internal/domain/entities&quot;&#10;&#9;&quot;github.com/igorrius/tcp-sproxy/internal/domain/repositories&quot;&#10;&#9;&quot;github.com/igorrius/tcp-sproxy/internal/domain/valueobjects&quot;&#10;&#9;&quot;github.com/igorrius/tcp-sproxy/pkg/transport&quot;&#10;&#9;&quot;github.com/sirupsen/logrus&quot;&#10;)&#10;&#10;// ProxyService handles the core proxy business logic&#10;type ProxyService struct {&#10;&#9;connectionRepo repositories.ConnectionRepository&#10;&#9;transport      transport.Transport&#10;&#9;logger         *logrus.Entry&#10;}&#10;&#10;// NewProxyService creates a new proxy service&#10;func NewProxyService(connectionRepo repositories.ConnectionRepository, transport transport.Transport, logger *logrus.Entry) *ProxyService {&#10;&#9;return &amp;ProxyService{&#10;&#9;&#9;connectionRepo: connectionRepo,&#10;&#9;&#9;transport:      transport,&#10;&#9;&#9;logger:         logger.WithField(&quot;service&quot;, &quot;proxy&quot;),&#10;&#9;}&#10;}&#10;&#10;// ProxyConnection handles a new connection request&#10;func (ps *ProxyService) ProxyConnection(ctx context.Context, clientConn net.Conn, remoteHost string, remotePort int) error {&#10;&#9;// Create new connection entity&#10;&#9;connID := valueobjects.NewConnectionID()&#10;&#9;connection := entities.NewConnection(connID, clientConn.RemoteAddr(), &amp;net.TCPAddr{&#10;&#9;&#9;IP:   net.ParseIP(remoteHost),&#10;&#9;&#9;Port: remotePort,&#10;&#9;})&#10;&#10;&#9;// Store connection&#10;&#9;if err := ps.connectionRepo.Store(ctx, connection); err != nil {&#10;&#9;&#9;ps.logger.WithError(err).Error(&quot;Failed to store connection&quot;)&#10;&#9;&#9;return fmt.Errorf(&quot;failed to store connection: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;ps.logger.WithFields(logrus.Fields{&#10;&#9;&#9;&quot;connection_id&quot;: connID.String(),&#10;&#9;&#9;&quot;client_addr&quot;:   clientConn.RemoteAddr(),&#10;&#9;&#9;&quot;remote_host&quot;:   remoteHost,&#10;&#9;&#9;&quot;remote_port&quot;:   remotePort,&#10;&#9;}).Info(&quot;New connection established&quot;)&#10;&#10;&#9;// Handle the connection in a goroutine&#10;&#9;// Status will be set to active inside the goroutine after successful connection&#10;&#9;go ps.handleConnection(ctx, connection, clientConn, remoteHost, remotePort)&#10;&#10;&#9;return nil&#10;}&#10;&#10;// HandleNATSProxyRequests subscribes to a NATS subject and handles incoming proxy requests.&#10;func (s *ProxyService) HandleNATSProxyRequests(ctx context.Context, subject string) error {&#10;&#9;msgChan, err := s.transport.Subscribe(ctx, subject)&#10;&#9;if err != nil {&#10;&#9;&#9;return fmt.Errorf(&quot;failed to subscribe to subject %s: %w&quot;, subject, err)&#10;&#9;}&#10;&#10;&#9;s.logger.WithField(&quot;subject&quot;, subject).Info(&quot;Listening for NATS proxy requests&quot;)&#10;&#10;&#9;for {&#10;&#9;&#9;select {&#10;&#9;&#9;case msg := &lt;-msgChan:&#10;&#9;&#9;&#9;// It's a request-reply, so we need to handle it in a goroutine&#10;&#9;&#9;&#9;// to not block the subscription loop.&#10;&#9;&#9;&#9;go func(m *transport.Message) {&#10;&#9;&#9;&#9;&#9;if err := s.handleIndividualProxyRequest(ctx, m); err != nil {&#10;&#9;&#9;&#9;&#9;&#9;s.logger.WithError(err).WithField(&quot;message_id&quot;, m.ID).Error(&quot;Failed to handle proxy request&quot;)&#10;&#9;&#9;&#9;&#9;&#9;// Optionally, send an error response back&#10;&#9;&#9;&#9;&#9;&#9;if m.Reply != &quot;&quot; {&#10;&#9;&#9;&#9;&#9;&#9;&#9;errorMsg := transport.NewMessage(m.ID, []byte(err.Error()))&#10;&#9;&#9;&#9;&#9;&#9;&#9;errorMsg.Metadata = map[string]string{&quot;error&quot;: &quot;true&quot;}&#10;&#9;&#9;&#9;&#9;&#9;&#9;if pubErr := s.transport.Publish(ctx, m.Reply, errorMsg); pubErr != nil {&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;s.logger.WithError(pubErr).Error(&quot;Failed to publish error response&quot;)&#10;&#9;&#9;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;}(msg)&#10;&#9;&#9;case &lt;-ctx.Done():&#10;&#9;&#9;&#9;s.logger.Info(&quot;Stopping NATS proxy request handler&quot;)&#10;&#9;&#9;&#9;return nil&#10;&#9;&#9;}&#10;&#9;}&#10;}&#10;&#10;// HandleNATSProxyRequest handles proxy requests from NATS messages&#10;func (ps *ProxyService) HandleNATSProxyRequest(ctx context.Context, msg *transport.Message) (*transport.Message, error) {&#10;&#9;// Extract remote host and port from message metadata&#10;&#9;remoteHost, ok := msg.Metadata[&quot;remote_host&quot;]&#10;&#9;if !ok {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;remote_host not found in message metadata&quot;)&#10;&#9;}&#10;&#10;&#9;remotePortStr, ok := msg.Metadata[&quot;remote_port&quot;]&#10;&#9;if !ok {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;remote_port not found in message metadata&quot;)&#10;&#9;}&#10;&#10;&#9;remotePort, err := strconv.Atoi(remotePortStr)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;invalid remote_port: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;// Resolve hostname to IP address&#10;&#9;ips, err := net.LookupIP(remoteHost)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;failed to resolve remote host: %w&quot;, err)&#10;&#9;}&#10;&#9;if len(ips) == 0 {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;no IP address found for remote host&quot;)&#10;&#9;}&#10;&#10;&#9;// Create virtual connection for NATS-based proxy&#10;&#9;connID := valueobjects.NewConnectionID()&#10;&#9;connection := entities.NewConnection(connID, &amp;net.TCPAddr{IP: net.IPv4(127, 0, 0, 1), Port: 0}, &amp;net.TCPAddr{&#10;&#9;&#9;IP:   ips[0],&#10;&#9;&#9;Port: remotePort,&#10;&#9;})&#10;&#10;&#9;// Store connection&#10;&#9;if err := ps.connectionRepo.Store(ctx, connection); err != nil {&#10;&#9;&#9;ps.logger.WithError(err).Error(&quot;Failed to store connection&quot;)&#10;&#9;&#9;return nil, fmt.Errorf(&quot;failed to store connection: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;ps.logger.WithFields(logrus.Fields{&#10;&#9;&#9;&quot;connection_id&quot;: connID.String(),&#10;&#9;&#9;&quot;remote_host&quot;:   remoteHost,&#10;&#9;&#9;&quot;remote_port&quot;:   remotePort,&#10;&#9;}).Info(&quot;New NATS proxy connection established&quot;)&#10;&#10;&#9;// Handle the NATS-based connection in a separate worker&#10;&#9;// Status will be set to active inside the goroutine after successful connection&#10;&#9;go ps.handleNATSConnection(ctx, connection, msg.Reply)&#10;&#10;&#9;return transport.NewMessage(msg.ID, []byte(connID.String())), nil&#10;}&#10;&#10;// handleNATSConnection manages the data flow for NATS-based connections&#10;func (ps *ProxyService) handleNATSConnection(ctx context.Context, connection *entities.Connection, replySubject string) {&#10;&#9;defer func() {&#10;&#9;&#9;connection.Close()&#10;&#9;&#9;ps.logger.WithField(&quot;connection_id&quot;, connection.ID.String()).Info(&quot;NATS connection handler finished&quot;)&#10;&#9;}()&#10;&#10;&#9;// Extract remote host and port from connection entity&#10;&#9;remoteHost := connection.ServerAddr.(*net.TCPAddr).IP.String()&#10;&#9;remotePort := connection.ServerAddr.(*net.TCPAddr).Port&#10;&#10;&#9;// Connect to remote server&#10;&#9;remoteAddr := net.JoinHostPort(remoteHost, fmt.Sprintf(&quot;%d&quot;, remotePort))&#10;&#9;remoteConn, err := net.DialTimeout(&quot;tcp&quot;, remoteAddr, 30*time.Second)&#10;&#9;if err != nil {&#10;&#9;&#9;ps.logger.WithError(err).WithField(&quot;connection_id&quot;, connection.ID.String()).Error(&quot;Failed to connect to remote server&quot;)&#10;&#9;&#9;connection.SetStatus(entities.ConnectionStatusError)&#10;&#9;&#9;return&#10;&#9;}&#10;&#9;defer remoteConn.Close()&#10;&#10;&#9;// Set connection as active only after successful connection&#10;&#9;connection.SetStatus(entities.ConnectionStatusActive)&#10;&#9;ps.logger.WithField(&quot;connection_id&quot;, connection.ID.String()).Info(&quot;Connected to remote server via NATS&quot;)&#10;&#10;&#9;// Create channels for coordination&#10;&#9;errChan := make(chan error, 2)&#10;&#10;&#9;// Start bidirectional data copying&#10;&#9;go func() {&#10;&#9;&#9;// remote -&gt; nats&#10;&#9;&#9;buf := make([]byte, 32*1024)&#10;&#9;&#9;for {&#10;&#9;&#9;&#9;n, err := remoteConn.Read(buf)&#10;&#9;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;&#9;if err != io.EOF {&#10;&#9;&#9;&#9;&#9;&#9;ps.logger.WithError(err).WithField(&quot;connection_id&quot;, connection.ID.String()).Error(&quot;Read error in remote-&gt;nats&quot;)&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;errChan &lt;- err&#10;&#9;&#9;&#9;&#9;return&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;ps.logger.WithField(&quot;connection_id&quot;, connection.ID.String()).Infof(&quot;remote-&gt;nats: read %d bytes&quot;, n)&#10;&#9;&#9;&#9;data := buf[:n]&#10;&#9;&#9;&#9;msg := transport.NewMessage(connection.ID.String(), data)&#10;&#9;&#9;&#9;subject := &quot;p.data.to_client.&quot; + connection.ID.String()&#10;&#9;&#9;&#9;if err := ps.transport.Publish(ctx, subject, msg); err != nil {&#10;&#9;&#9;&#9;&#9;ps.logger.WithError(err).WithField(&quot;connection_id&quot;, connection.ID.String()).Error(&quot;Failed to publish to nats&quot;)&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;}()&#10;&#10;&#9;go func() {&#10;&#9;&#9;// nats -&gt; remote&#10;&#9;&#9;subject := &quot;p.data.to_server.&quot; + connection.ID.String()&#10;&#9;&#9;msgChan, err := ps.transport.Subscribe(ctx, subject)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;ps.logger.WithError(err).WithField(&quot;connection_id&quot;, connection.ID.String()).Error(&quot;Failed to subscribe to nats&quot;)&#10;&#9;&#9;&#9;errChan &lt;- err&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;for {&#10;&#9;&#9;&#9;select {&#10;&#9;&#9;&#9;case msg := &lt;-msgChan:&#10;&#9;&#9;&#9;&#9;ps.logger.WithField(&quot;connection_id&quot;, connection.ID.String()).Infof(&quot;nats-&gt;remote: got message with %d bytes&quot;, len(msg.Data))&#10;&#9;&#9;&#9;&#9;if _, err := remoteConn.Write(msg.Data); err != nil {&#10;&#9;&#9;&#9;&#9;&#9;if err != io.EOF {&#10;&#9;&#9;&#9;&#9;&#9;&#9;ps.logger.WithError(err).WithField(&quot;connection_id&quot;, connection.ID.String()).Error(&quot;Write error in nats-&gt;remote&quot;)&#10;&#9;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;&#9;errChan &lt;- err&#10;&#9;&#9;&#9;&#9;&#9;return&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;case &lt;-ctx.Done():&#10;&#9;&#9;&#9;&#9;return&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;}()&#10;&#10;&#9;// Wait for either direction to finish or error&#10;&#9;&lt;-errChan&#10;&#9;connection.SetStatus(entities.ConnectionStatusClosed)&#10;&#9;ps.logger.WithField(&quot;connection_id&quot;, connection.ID.String()).Info(&quot;Connection closed&quot;)&#10;}&#10;&#10;// handleConnection manages the data flow between client and remote server&#10;func (ps *ProxyService) handleConnection(ctx context.Context, connection *entities.Connection, clientConn net.Conn, remoteHost string, remotePort int) {&#10;&#9;defer func() {&#10;&#9;&#9;clientConn.Close()&#10;&#9;&#9;connection.Close()&#10;&#9;&#9;ps.logger.WithField(&quot;connection_id&quot;, connection.ID.String()).Info(&quot;Connection handler finished&quot;)&#10;&#9;}()&#10;&#10;&#9;// Connect to remote server&#10;&#9;remoteAddr := net.JoinHostPort(remoteHost, fmt.Sprintf(&quot;%d&quot;, remotePort))&#10;&#9;remoteConn, err := net.DialTimeout(&quot;tcp&quot;, remoteAddr, 30*time.Second)&#10;&#9;if err != nil {&#10;&#9;&#9;ps.logger.WithError(err).WithField(&quot;connection_id&quot;, connection.ID.String()).Error(&quot;Failed to connect to remote server&quot;)&#10;&#9;&#9;connection.SetStatus(entities.ConnectionStatusError)&#10;&#9;&#9;return&#10;&#9;}&#10;&#9;defer remoteConn.Close()&#10;&#10;&#9;// Set connection as active only after successful connection&#10;&#9;connection.SetStatus(entities.ConnectionStatusActive)&#10;&#9;ps.logger.WithField(&quot;connection_id&quot;, connection.ID.String()).Info(&quot;Connected to remote server&quot;)&#10;&#10;&#9;// Create channels for coordination&#10;&#9;errChan := make(chan error, 2)&#10;&#9;doneChan := make(chan struct{})&#10;&#10;&#9;// Start bidirectional data copying&#10;&#9;go ps.copyData(ctx, connection, clientConn, remoteConn, &quot;client-&gt;remote&quot;, errChan)&#10;&#9;go ps.copyData(ctx, connection, remoteConn, clientConn, &quot;remote-&gt;client&quot;, errChan)&#10;&#10;&#9;// Wait for either direction to finish or error&#10;&#9;select {&#10;&#9;case err := &lt;-errChan:&#10;&#9;&#9;if err != nil &amp;&amp; err != io.EOF {&#10;&#9;&#9;&#9;ps.logger.WithError(err).WithField(&quot;connection_id&quot;, connection.ID.String()).Error(&quot;Connection error&quot;)&#10;&#9;&#9;}&#10;&#9;case &lt;-ctx.Done():&#10;&#9;&#9;ps.logger.WithField(&quot;connection_id&quot;, connection.ID.String()).Info(&quot;Connection cancelled by context&quot;)&#10;&#9;case &lt;-doneChan:&#10;&#9;&#9;ps.logger.WithField(&quot;connection_id&quot;, connection.ID.String()).Info(&quot;Connection completed normally&quot;)&#10;&#9;}&#10;}&#10;&#10;// copyData copies data from src to dst while updating connection activity&#10;func (ps *ProxyService) copyData(ctx context.Context, connection *entities.Connection, src, dst net.Conn, direction string, errChan chan&lt;- error) {&#10;&#9;defer func() {&#10;&#9;&#9;errChan &lt;- io.EOF&#10;&#9;}()&#10;&#10;&#9;buffer := make([]byte, 32*1024) // 32KB buffer&#10;&#9;for {&#10;&#9;&#9;select {&#10;&#9;&#9;case &lt;-ctx.Done():&#10;&#9;&#9;&#9;return&#10;&#9;&#9;default:&#10;&#9;&#9;&#9;// Set read deadline&#10;&#9;&#9;&#9;src.SetReadDeadline(time.Now().Add(30 * time.Second))&#10;&#10;&#9;&#9;&#9;n, err := src.Read(buffer)&#10;&#9;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;&#9;if err != io.EOF {&#10;&#9;&#9;&#9;&#9;&#9;ps.logger.WithError(err).WithField(&quot;connection_id&quot;, connection.ID.String()).Errorf(&quot;Read error in %s&quot;, direction)&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;return&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;if n &gt; 0 {&#10;&#9;&#9;&#9;&#9;// Update connection activity&#10;&#9;&#9;&#9;&#9;connection.UpdateActivity()&#10;&#10;&#9;&#9;&#9;&#9;// Write data to destination&#10;&#9;&#9;&#9;&#9;dst.SetWriteDeadline(time.Now().Add(30 * time.Second))&#10;&#9;&#9;&#9;&#9;_, writeErr := dst.Write(buffer[:n])&#10;&#9;&#9;&#9;&#9;if writeErr != nil {&#10;&#9;&#9;&#9;&#9;&#9;ps.logger.WithError(writeErr).WithField(&quot;connection_id&quot;, connection.ID.String()).Errorf(&quot;Write error in %s&quot;, direction)&#10;&#9;&#9;&#9;&#9;&#9;return&#10;&#9;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;&#9;ps.logger.WithFields(logrus.Fields{&#10;&#9;&#9;&#9;&#9;&#9;&quot;connection_id&quot;: connection.ID.String(),&#10;&#9;&#9;&#9;&#9;&#9;&quot;direction&quot;:     direction,&#10;&#9;&#9;&#9;&#9;&#9;&quot;bytes&quot;:         n,&#10;&#9;&#9;&#9;&#9;}).Debug(&quot;Data copied&quot;)&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;}&#10;}&#10;&#10;// GetActiveConnections returns all active connections&#10;func (ps *ProxyService) GetActiveConnections(ctx context.Context) ([]*entities.Connection, error) {&#10;&#9;return ps.connectionRepo.GetActive(ctx)&#10;}&#10;&#10;// CloseConnection closes a specific connection&#10;func (ps *ProxyService) CloseConnection(ctx context.Context, connID valueobjects.ConnectionID) error {&#10;&#9;connection, err := ps.connectionRepo.GetByID(ctx, connID)&#10;&#9;if err != nil {&#10;&#9;&#9;return fmt.Errorf(&quot;failed to get connection: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;connection.Close()&#10;&#9;return ps.connectionRepo.Update(ctx, connection)&#10;}&#10;&#10;// GetConnectionStats returns statistics about connections&#10;func (ps *ProxyService) GetConnectionStats(ctx context.Context) (*ConnectionStats, error) {&#10;&#9;connections, err := ps.connectionRepo.GetAll(ctx)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;failed to get connections: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;stats := &amp;ConnectionStats{&#10;&#9;&#9;Total:     len(connections),&#10;&#9;&#9;Active:    0,&#10;&#9;&#9;Closed:    0,&#10;&#9;&#9;Error:     0,&#10;&#9;&#9;New:       0,&#10;&#9;&#9;CreatedAt: time.Now(),&#10;&#9;}&#10;&#10;&#9;for _, conn := range connections {&#10;&#9;&#9;switch conn.GetStatus() {&#10;&#9;&#9;case entities.ConnectionStatusActive:&#10;&#9;&#9;&#9;stats.Active++&#10;&#9;&#9;case entities.ConnectionStatusClosed:&#10;&#9;&#9;&#9;stats.Closed++&#10;&#9;&#9;case entities.ConnectionStatusError:&#10;&#9;&#9;&#9;stats.Error++&#10;&#9;&#9;case entities.ConnectionStatusNew:&#10;&#9;&#9;&#9;stats.New++&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;return stats, nil&#10;}&#10;&#10;// ConnectionStats represents connection statistics&#10;type ConnectionStats struct {&#10;&#9;Total     int       `json:&quot;total&quot;`&#10;&#9;Active    int       `json:&quot;active&quot;`&#10;&#9;Closed    int       `json:&quot;closed&quot;`&#10;&#9;Error     int       `json:&quot;error&quot;`&#10;&#9;New       int       `json:&quot;new&quot;`&#10;&#9;CreatedAt time.Time `json:&quot;created_at&quot;`&#10;}&#10;&#10;// handleIndividualProxyRequest handles individual proxy requests&#10;func (s *ProxyService) handleIndividualProxyRequest(ctx context.Context, msg *transport.Message) error {&#10;&#9;s.logger.WithField(&quot;message_id&quot;, msg.ID).Info(&quot;Handling new NATS proxy request&quot;)&#10;&#10;&#9;// Log the entire message for debugging&#10;&#9;s.logger.WithField(&quot;message&quot;, fmt.Sprintf(&quot;%+v&quot;, msg)).Debug(&quot;Received proxy request message&quot;)&#10;&#10;&#9;// Extract remote host and port from message metadata&#10;&#9;remoteHost, ok := msg.Metadata[&quot;remote_host&quot;]&#10;&#9;if !ok {&#10;&#9;&#9;return fmt.Errorf(&quot;remote_host not found in message metadata&quot;)&#10;&#9;}&#10;&#10;&#9;remotePortStr, ok := msg.Metadata[&quot;remote_port&quot;]&#10;&#9;if !ok {&#10;&#9;&#9;return fmt.Errorf(&quot;remote_port not found in message metadata&quot;)&#10;&#9;}&#10;&#10;&#9;remotePort, err := strconv.Atoi(remotePortStr)&#10;&#9;if err != nil {&#10;&#9;&#9;return fmt.Errorf(&quot;invalid remote_port: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;// Resolve hostname to IP address&#10;&#9;ips, err := net.LookupIP(remoteHost)&#10;&#9;if err != nil {&#10;&#9;&#9;return fmt.Errorf(&quot;failed to resolve remote host: %w&quot;, err)&#10;&#9;}&#10;&#9;if len(ips) == 0 {&#10;&#9;&#9;return fmt.Errorf(&quot;no IP address found for remote host&quot;)&#10;&#9;}&#10;&#10;&#9;// Create virtual connection for NATS-based proxy&#10;&#9;connID := valueobjects.NewConnectionID()&#10;&#9;connection := entities.NewConnection(connID, &amp;net.TCPAddr{IP: net.IPv4(127, 0, 0, 1), Port: 0}, &amp;net.TCPAddr{&#10;&#9;&#9;IP:   ips[0],&#10;&#9;&#9;Port: remotePort,&#10;&#9;})&#10;&#10;&#9;// Store connection&#10;&#9;if err := s.connectionRepo.Store(ctx, connection); err != nil {&#10;&#9;&#9;s.logger.WithError(err).Error(&quot;Failed to store connection&quot;)&#10;&#9;&#9;return fmt.Errorf(&quot;failed to store connection: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;s.logger.WithFields(logrus.Fields{&#10;&#9;&#9;&quot;connection_id&quot;: connID.String(),&#10;&#9;&#9;&quot;remote_host&quot;:   remoteHost,&#10;&#9;&#9;&quot;remote_port&quot;:   remotePort,&#10;&#9;}).Info(&quot;New NATS proxy connection established&quot;)&#10;&#10;&#9;// Handle the NATS-based connection in a separate worker&#10;&#9;// Status will be set to active inside the goroutine after successful connection&#10;&#9;go s.handleNATSConnection(ctx, connection, msg.Reply)&#10;&#10;&#9;responseMsg := transport.NewMessage(msg.ID, []byte(connID.String()))&#10;&#9;if msg.Reply != &quot;&quot; {&#10;&#9;&#9;if err := s.transport.Publish(ctx, msg.Reply, responseMsg); err != nil {&#10;&#9;&#9;&#9;return fmt.Errorf(&quot;failed to send response: %w&quot;, err)&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;" />
              <option name="updatedContent" value="package services&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;io&quot;&#10;&#9;&quot;net&quot;&#10;&#9;&quot;strconv&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;github.com/igorrius/tcp-sproxy/internal/domain/entities&quot;&#10;&#9;&quot;github.com/igorrius/tcp-sproxy/internal/domain/repositories&quot;&#10;&#9;&quot;github.com/igorrius/tcp-sproxy/internal/domain/valueobjects&quot;&#10;&#9;&quot;github.com/igorrius/tcp-sproxy/pkg/transport&quot;&#10;&#9;&quot;github.com/sirupsen/logrus&quot;&#10;)&#10;&#10;// ProxyService handles the core proxy business logic&#10;type ProxyService struct {&#10;&#9;connectionRepo repositories.ConnectionRepository&#10;&#9;transport      transport.Transport&#10;&#9;logger         *logrus.Entry&#10;}&#10;&#10;// NewProxyService creates a new proxy service&#10;func NewProxyService(connectionRepo repositories.ConnectionRepository, transport transport.Transport, logger *logrus.Entry) *ProxyService {&#10;&#9;return &amp;ProxyService{&#10;&#9;&#9;connectionRepo: connectionRepo,&#10;&#9;&#9;transport:      transport,&#10;&#9;&#9;logger:         logger.WithField(&quot;service&quot;, &quot;proxy&quot;),&#10;&#9;}&#10;}&#10;&#10;// ProxyConnection handles a new connection request&#10;func (ps *ProxyService) ProxyConnection(ctx context.Context, clientConn net.Conn, remoteHost string, remotePort int) error {&#10;&#9;// Create new connection entity&#10;&#9;connID := valueobjects.NewConnectionID()&#10;&#9;connection := entities.NewConnection(connID, clientConn.RemoteAddr(), &amp;net.TCPAddr{&#10;&#9;&#9;IP:   net.ParseIP(remoteHost),&#10;&#9;&#9;Port: remotePort,&#10;&#9;})&#10;&#10;&#9;// Store connection&#10;&#9;if err := ps.connectionRepo.Store(ctx, connection); err != nil {&#10;&#9;&#9;ps.logger.WithError(err).Error(&quot;Failed to store connection&quot;)&#10;&#9;&#9;return fmt.Errorf(&quot;failed to store connection: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;ps.logger.WithFields(logrus.Fields{&#10;&#9;&#9;&quot;connection_id&quot;: connID.String(),&#10;&#9;&#9;&quot;client_addr&quot;:   clientConn.RemoteAddr(),&#10;&#9;&#9;&quot;remote_host&quot;:   remoteHost,&#10;&#9;&#9;&quot;remote_port&quot;:   remotePort,&#10;&#9;}).Info(&quot;New connection established&quot;)&#10;&#10;&#9;// Handle the connection in a goroutine&#10;&#9;// Status will be set to active inside the goroutine after successful connection&#10;&#9;go ps.handleConnection(ctx, connection, clientConn, remoteHost, remotePort)&#10;&#10;&#9;return nil&#10;}&#10;&#10;// HandleNATSProxyRequests subscribes to a NATS subject and handles incoming proxy requests.&#10;func (s *ProxyService) HandleNATSProxyRequests(ctx context.Context, subject string) error {&#10;&#9;msgChan, err := s.transport.Subscribe(ctx, subject)&#10;&#9;if err != nil {&#10;&#9;&#9;return fmt.Errorf(&quot;failed to subscribe to subject %s: %w&quot;, subject, err)&#10;&#9;}&#10;&#10;&#9;s.logger.WithField(&quot;subject&quot;, subject).Info(&quot;Listening for NATS proxy requests&quot;)&#10;&#10;&#9;for {&#10;&#9;&#9;select {&#10;&#9;&#9;case msg := &lt;-msgChan:&#10;&#9;&#9;&#9;go func(m *transport.Message) {&#10;&#9;&#9;&#9;&#9;if err := s.handleIndividualProxyRequest(ctx, m); err != nil {&#10;&#9;&#9;&#9;&#9;&#9;s.logger.WithError(err).WithField(&quot;message_id&quot;, m.ID).Error(&quot;Failed to handle proxy request&quot;)&#10;&#9;&#9;&#9;&#9;&#9;if m.Reply != &quot;&quot; {&#10;&#9;&#9;&#9;&#9;&#9;&#9;errorMsg := transport.NewMessage(m.ID, []byte(err.Error()))&#10;&#9;&#9;&#9;&#9;&#9;&#9;errorMsg.Metadata = map[string]string{&quot;error&quot;: &quot;true&quot;}&#10;&#9;&#9;&#9;&#9;&#9;&#9;if pubErr := s.transport.Publish(ctx, m.Reply, errorMsg); pubErr != nil {&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;s.logger.WithError(pubErr).Error(&quot;Failed to publish error response&quot;)&#10;&#9;&#9;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;}(msg)&#10;&#9;&#9;case &lt;-ctx.Done():&#10;&#9;&#9;&#9;s.logger.Info(&quot;Stopping NATS proxy request handler&quot;)&#10;&#9;&#9;&#9;return nil&#10;&#9;&#9;}&#10;&#9;}&#10;}&#10;&#10;// handleIndividualProxyRequest handles individual proxy requests&#10;func (s *ProxyService) handleIndividualProxyRequest(ctx context.Context, msg *transport.Message) error {&#10;&#9;s.logger.WithField(&quot;message_id&quot;, msg.ID).Info(&quot;Handling new NATS proxy request&quot;)&#10;&#10;&#9;remoteHost, ok := msg.Metadata[&quot;remote_host&quot;]&#10;&#9;if !ok {&#10;&#9;&#9;return fmt.Errorf(&quot;remote_host not found in message metadata&quot;)&#10;&#9;}&#10;&#10;&#9;remotePortStr, ok := msg.Metadata[&quot;remote_port&quot;]&#10;&#9;if !ok {&#10;&#9;&#9;return fmt.Errorf(&quot;remote_port not found in message metadata&quot;)&#10;&#9;}&#10;&#10;&#9;remotePort, err := strconv.Atoi(remotePortStr)&#10;&#9;if err != nil {&#10;&#9;&#9;return fmt.Errorf(&quot;invalid remote_port: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;ips, err := net.LookupIP(remoteHost)&#10;&#9;if err != nil {&#10;&#9;&#9;return fmt.Errorf(&quot;failed to resolve remote host: %w&quot;, err)&#10;&#9;}&#10;&#9;if len(ips) == 0 {&#10;&#9;&#9;return fmt.Errorf(&quot;no IP address found for remote host&quot;)&#10;&#9;}&#10;&#10;&#9;connID := valueobjects.NewConnectionID()&#10;&#9;connection := entities.NewConnection(connID, &amp;net.TCPAddr{IP: net.IPv4(127, 0, 0, 1), Port: 0}, &amp;net.TCPAddr{&#10;&#9;&#9;IP:   ips[0],&#10;&#9;&#9;Port: remotePort,&#10;&#9;})&#10;&#10;&#9;if err := s.connectionRepo.Store(ctx, connection); err != nil {&#10;&#9;&#9;s.logger.WithError(err).Error(&quot;Failed to store connection&quot;)&#10;&#9;&#9;return fmt.Errorf(&quot;failed to store connection: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;s.logger.WithFields(logrus.Fields{&#10;&#9;&#9;&quot;connection_id&quot;: connID.String(),&#10;&#9;&#9;&quot;remote_host&quot;:   remoteHost,&#10;&#9;&#9;&quot;remote_port&quot;:   remotePort,&#10;&#9;}).Info(&quot;New NATS proxy connection established&quot;)&#10;&#10;&#9;go s.handleNATSConnection(ctx, connection, msg.Reply)&#10;&#10;&#9;responseMsg := transport.NewMessage(msg.ID, []byte(connID.String()))&#10;&#9;if msg.Reply != &quot;&quot; {&#10;&#9;&#9;if err := s.transport.Publish(ctx, msg.Reply, responseMsg); err != nil {&#10;&#9;&#9;&#9;return fmt.Errorf(&quot;failed to send response: %w&quot;, err)&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;&#10;// handleNATSConnection manages the data flow for NATS-based connections&#10;func (ps *ProxyService) handleNATSConnection(ctx context.Context, connection *entities.Connection, replySubject string) {&#10;&#9;defer func() {&#10;&#9;&#9;connection.Close()&#10;&#9;&#9;ps.logger.WithField(&quot;connection_id&quot;, connection.ID.String()).Info(&quot;NATS connection handler finished&quot;)&#10;&#9;}()&#10;&#10;&#9;// Extract remote host and port from connection entity&#10;&#9;remoteHost := connection.ServerAddr.(*net.TCPAddr).IP.String()&#10;&#9;remotePort := connection.ServerAddr.(*net.TCPAddr).Port&#10;&#10;&#9;// Connect to remote server&#10;&#9;remoteAddr := net.JoinHostPort(remoteHost, fmt.Sprintf(&quot;%d&quot;, remotePort))&#10;&#9;remoteConn, err := net.DialTimeout(&quot;tcp&quot;, remoteAddr, 30*time.Second)&#10;&#9;if err != nil {&#10;&#9;&#9;ps.logger.WithError(err).WithField(&quot;connection_id&quot;, connection.ID.String()).Error(&quot;Failed to connect to remote server&quot;)&#10;&#9;&#9;connection.SetStatus(entities.ConnectionStatusError)&#10;&#9;&#9;return&#10;&#9;}&#10;&#9;defer remoteConn.Close()&#10;&#10;&#9;// Set connection as active only after successful connection&#10;&#9;connection.SetStatus(entities.ConnectionStatusActive)&#10;&#9;ps.logger.WithField(&quot;connection_id&quot;, connection.ID.String()).Info(&quot;Connected to remote server via NATS&quot;)&#10;&#10;&#9;// Create channels for coordination&#10;&#9;errChan := make(chan error, 2)&#10;&#10;&#9;// Start bidirectional data copying&#10;&#9;go func() {&#10;&#9;&#9;// remote -&gt; nats&#10;&#9;&#9;buf := make([]byte, 32*1024)&#10;&#9;&#9;for {&#10;&#9;&#9;&#9;n, err := remoteConn.Read(buf)&#10;&#9;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;&#9;if err != io.EOF {&#10;&#9;&#9;&#9;&#9;&#9;ps.logger.WithError(err).WithField(&quot;connection_id&quot;, connection.ID.String()).Error(&quot;Read error in remote-&gt;nats&quot;)&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;errChan &lt;- err&#10;&#9;&#9;&#9;&#9;return&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;ps.logger.WithField(&quot;connection_id&quot;, connection.ID.String()).Infof(&quot;remote-&gt;nats: read %d bytes&quot;, n)&#10;&#9;&#9;&#9;data := buf[:n]&#10;&#9;&#9;&#9;msg := transport.NewMessage(connection.ID.String(), data)&#10;&#9;&#9;&#9;subject := &quot;p.data.to_client.&quot; + connection.ID.String()&#10;&#9;&#9;&#9;if err := ps.transport.Publish(ctx, subject, msg); err != nil {&#10;&#9;&#9;&#9;&#9;ps.logger.WithError(err).WithField(&quot;connection_id&quot;, connection.ID.String()).Error(&quot;Failed to publish to nats&quot;)&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;}()&#10;&#10;&#9;go func() {&#10;&#9;&#9;// nats -&gt; remote&#10;&#9;&#9;subject := &quot;p.data.to_server.&quot; + connection.ID.String()&#10;&#9;&#9;msgChan, err := ps.transport.Subscribe(ctx, subject)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;ps.logger.WithError(err).WithField(&quot;connection_id&quot;, connection.ID.String()).Error(&quot;Failed to subscribe to nats&quot;)&#10;&#9;&#9;&#9;errChan &lt;- err&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;for {&#10;&#9;&#9;&#9;select {&#10;&#9;&#9;&#9;case msg := &lt;-msgChan:&#10;&#9;&#9;&#9;&#9;ps.logger.WithField(&quot;connection_id&quot;, connection.ID.String()).Infof(&quot;nats-&gt;remote: got message with %d bytes&quot;, len(msg.Data))&#10;&#9;&#9;&#9;&#9;if _, err := remoteConn.Write(msg.Data); err != nil {&#10;&#9;&#9;&#9;&#9;&#9;if err != io.EOF {&#10;&#9;&#9;&#9;&#9;&#9;&#9;ps.logger.WithError(err).WithField(&quot;connection_id&quot;, connection.ID.String()).Error(&quot;Write error in nats-&gt;remote&quot;)&#10;&#9;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;&#9;errChan &lt;- err&#10;&#9;&#9;&#9;&#9;&#9;return&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;case &lt;-ctx.Done():&#10;&#9;&#9;&#9;&#9;return&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;}()&#10;&#10;&#9;// Wait for either direction to finish or error&#10;&#9;&lt;-errChan&#10;&#9;connection.SetStatus(entities.ConnectionStatusClosed)&#10;&#9;ps.logger.WithField(&quot;connection_id&quot;, connection.ID.String()).Info(&quot;Connection closed&quot;)&#10;}&#10;&#10;// handleConnection manages the data flow between client and remote server&#10;func (ps *ProxyService) handleConnection(ctx context.Context, connection *entities.Connection, clientConn net.Conn, remoteHost string, remotePort int) {&#10;&#9;defer func() {&#10;&#9;&#9;clientConn.Close()&#10;&#9;&#9;connection.Close()&#10;&#9;&#9;ps.logger.WithField(&quot;connection_id&quot;, connection.ID.String()).Info(&quot;Connection handler finished&quot;)&#10;&#9;}()&#10;&#10;&#9;// Connect to remote server&#10;&#9;remoteAddr := net.JoinHostPort(remoteHost, fmt.Sprintf(&quot;%d&quot;, remotePort))&#10;&#9;remoteConn, err := net.DialTimeout(&quot;tcp&quot;, remoteAddr, 30*time.Second)&#10;&#9;if err != nil {&#10;&#9;&#9;ps.logger.WithError(err).WithField(&quot;connection_id&quot;, connection.ID.String()).Error(&quot;Failed to connect to remote server&quot;)&#10;&#9;&#9;connection.SetStatus(entities.ConnectionStatusError)&#10;&#9;&#9;return&#10;&#9;}&#10;&#9;defer remoteConn.Close()&#10;&#10;&#9;// Set connection as active only after successful connection&#10;&#9;connection.SetStatus(entities.ConnectionStatusActive)&#10;&#9;ps.logger.WithField(&quot;connection_id&quot;, connection.ID.String()).Info(&quot;Connected to remote server&quot;)&#10;&#10;&#9;// Create channels for coordination&#10;&#9;errChan := make(chan error, 2)&#10;&#9;doneChan := make(chan struct{})&#10;&#10;&#9;// Start bidirectional data copying&#10;&#9;go ps.copyData(ctx, connection, clientConn, remoteConn, &quot;client-&gt;remote&quot;, errChan)&#10;&#9;go ps.copyData(ctx, connection, remoteConn, clientConn, &quot;remote-&gt;client&quot;, errChan)&#10;&#10;&#9;// Wait for either direction to finish or error&#10;&#9;select {&#10;&#9;case err := &lt;-errChan:&#10;&#9;&#9;if err != nil &amp;&amp; err != io.EOF {&#10;&#9;&#9;&#9;ps.logger.WithError(err).WithField(&quot;connection_id&quot;, connection.ID.String()).Error(&quot;Connection error&quot;)&#10;&#9;&#9;}&#10;&#9;case &lt;-ctx.Done():&#10;&#9;&#9;ps.logger.WithField(&quot;connection_id&quot;, connection.ID.String()).Info(&quot;Connection cancelled by context&quot;)&#10;&#9;case &lt;-doneChan:&#10;&#9;&#9;ps.logger.WithField(&quot;connection_id&quot;, connection.ID.String()).Info(&quot;Connection completed normally&quot;)&#10;&#9;}&#10;}&#10;&#10;// copyData copies data from src to dst while updating connection activity&#10;func (ps *ProxyService) copyData(ctx context.Context, connection *entities.Connection, src, dst net.Conn, direction string, errChan chan&lt;- error) {&#10;&#9;defer func() {&#10;&#9;&#9;errChan &lt;- io.EOF&#10;&#9;}()&#10;&#10;&#9;buffer := make([]byte, 32*1024) // 32KB buffer&#10;&#9;for {&#10;&#9;&#9;select {&#10;&#9;&#9;case &lt;-ctx.Done():&#10;&#9;&#9;&#9;return&#10;&#9;&#9;default:&#10;&#9;&#9;&#9;// Set read deadline&#10;&#9;&#9;&#9;src.SetReadDeadline(time.Now().Add(30 * time.Second))&#10;&#10;&#9;&#9;&#9;n, err := src.Read(buffer)&#10;&#9;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;&#9;if err != io.EOF {&#10;&#9;&#9;&#9;&#9;&#9;ps.logger.WithError(err).WithField(&quot;connection_id&quot;, connection.ID.String()).Errorf(&quot;Read error in %s&quot;, direction)&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;return&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;if n &gt; 0 {&#10;&#9;&#9;&#9;&#9;// Update connection activity&#10;&#9;&#9;&#9;&#9;connection.UpdateActivity()&#10;&#10;&#9;&#9;&#9;&#9;// Write data to destination&#10;&#9;&#9;&#9;&#9;dst.SetWriteDeadline(time.Now().Add(30 * time.Second))&#10;&#9;&#9;&#9;&#9;_, writeErr := dst.Write(buffer[:n])&#10;&#9;&#9;&#9;&#9;if writeErr != nil {&#10;&#9;&#9;&#9;&#9;&#9;ps.logger.WithError(writeErr).WithField(&quot;connection_id&quot;, connection.ID.String()).Errorf(&quot;Write error in %s&quot;, direction)&#10;&#9;&#9;&#9;&#9;&#9;return&#10;&#9;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;&#9;ps.logger.WithFields(logrus.Fields{&#10;&#9;&#9;&#9;&#9;&#9;&quot;connection_id&quot;: connection.ID.String(),&#10;&#9;&#9;&#9;&#9;&#9;&quot;direction&quot;:     direction,&#10;&#9;&#9;&#9;&#9;&#9;&quot;bytes&quot;:         n,&#10;&#9;&#9;&#9;&#9;}).Debug(&quot;Data copied&quot;)&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;}&#10;}&#10;&#10;// GetActiveConnections returns all active connections&#10;func (ps *ProxyService) GetActiveConnections(ctx context.Context) ([]*entities.Connection, error) {&#10;&#9;return ps.connectionRepo.GetActive(ctx)&#10;}&#10;&#10;// CloseConnection closes a specific connection&#10;func (ps *ProxyService) CloseConnection(ctx context.Context, connID valueobjects.ConnectionID) error {&#10;&#9;connection, err := ps.connectionRepo.GetByID(ctx, connID)&#10;&#9;if err != nil {&#10;&#9;&#9;return fmt.Errorf(&quot;failed to get connection: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;connection.Close()&#10;&#9;return ps.connectionRepo.Update(ctx, connection)&#10;}&#10;&#10;// GetConnectionStats returns statistics about connections&#10;func (ps *ProxyService) GetConnectionStats(ctx context.Context) (*ConnectionStats, error) {&#10;&#9;connections, err := ps.connectionRepo.GetAll(ctx)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;failed to get connections: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;stats := &amp;ConnectionStats{&#10;&#9;&#9;Total:     len(connections),&#10;&#9;&#9;Active:    0,&#10;&#9;&#9;Closed:    0,&#10;&#9;&#9;Error:     0,&#10;&#9;&#9;New:       0,&#10;&#9;&#9;CreatedAt: time.Now(),&#10;&#9;}&#10;&#10;&#9;for _, conn := range connections {&#10;&#9;&#9;switch conn.GetStatus() {&#10;&#9;&#9;case entities.ConnectionStatusActive:&#10;&#9;&#9;&#9;stats.Active++&#10;&#9;&#9;case entities.ConnectionStatusClosed:&#10;&#9;&#9;&#9;stats.Closed++&#10;&#9;&#9;case entities.ConnectionStatusError:&#10;&#9;&#9;&#9;stats.Error++&#10;&#9;&#9;case entities.ConnectionStatusNew:&#10;&#9;&#9;&#9;stats.New++&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;return stats, nil&#10;}&#10;&#10;// ConnectionStats represents connection statistics&#10;type ConnectionStats struct {&#10;&#9;Total     int       `json:&quot;total&quot;`&#10;&#9;Active    int       `json:&quot;active&quot;`&#10;&#9;Closed    int       `json:&quot;closed&quot;`&#10;&#9;Error     int       `json:&quot;error&quot;`&#10;&#9;New       int       `json:&quot;new&quot;`&#10;&#9;CreatedAt time.Time `json:&quot;created_at&quot;`&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/infrastructure/transport/nats_transport.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/infrastructure/transport/nats_transport.go" />
              <option name="originalContent" value="package transport&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;encoding/json&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;io&quot;&#10;&#9;&quot;net&quot;&#10;&#9;&quot;sync&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;github.com/igorrius/tcp-sproxy/pkg/transport&quot;&#10;&#9;&quot;github.com/nats-io/nats.go&quot;&#10;&#9;&quot;github.com/sirupsen/logrus&quot;&#10;)&#10;&#10;// NATSTransport implements the Transport interface using NATS&#10;type NATSTransport struct {&#10;&#9;conn    *nats.Conn&#10;&#9;js      nats.JetStreamContext&#10;&#9;config  *NATSConfig&#10;&#9;logger  *logrus.Entry&#10;&#9;mu      sync.RWMutex&#10;&#9;subs    map[string]*nats.Subscription&#10;&#9;msgChan chan *transport.Message&#10;}&#10;&#10;// NATSConfig represents NATS-specific configuration&#10;type NATSConfig struct {&#10;&#9;URL     string            `json:&quot;url&quot;`&#10;&#9;Options map[string]string `json:&quot;options&quot;`&#10;&#9;Timeout time.Duration     `json:&quot;timeout&quot;`&#10;&#9;Retries int               `json:&quot;retries&quot;`&#10;&#9;Stream  string            `json:&quot;stream&quot;`&#10;&#9;Subject string            `json:&quot;subject&quot;`&#10;}&#10;&#10;// NewNATSTransport creates a new NATS transport instance&#10;func NewNATSTransport(logger *logrus.Entry) *NATSTransport {&#10;&#9;return &amp;NATSTransport{&#10;&#9;&#9;subs:    make(map[string]*nats.Subscription),&#10;&#9;&#9;msgChan: make(chan *transport.Message, 100),&#10;&#9;&#9;logger:  logger,&#10;&#9;}&#10;}&#10;&#10;// Connect establishes a connection to NATS server&#10;func (nt *NATSTransport) Connect(ctx context.Context, config interface{}) error {&#10;&#9;nt.mu.Lock()&#10;&#9;defer nt.mu.Unlock()&#10;&#10;&#9;cfg, ok := config.(*NATSConfig)&#10;&#9;if !ok {&#10;&#9;&#9;return fmt.Errorf(&quot;invalid config type for NATS transport&quot;)&#10;&#9;}&#10;&#9;nt.config = cfg&#10;&#10;&#9;// Set default timeout if not provided&#10;&#9;if cfg.Timeout == 0 {&#10;&#9;&#9;cfg.Timeout = 30 * time.Second&#10;&#9;}&#10;&#10;&#9;// Connect to NATS&#10;&#9;opts := []nats.Option{&#10;&#9;&#9;nats.Timeout(cfg.Timeout),&#10;&#9;&#9;nats.ReconnectWait(1 * time.Second),&#10;&#9;&#9;nats.MaxReconnects(-1), // Unlimited reconnects&#10;&#9;&#9;nats.DisconnectErrHandler(func(nc *nats.Conn, err error) {&#10;&#9;&#9;&#9;nt.logger.WithError(err).Warn(&quot;NATS disconnected&quot;)&#10;&#9;&#9;}),&#10;&#9;&#9;nats.ReconnectHandler(func(nc *nats.Conn) {&#10;&#9;&#9;&#9;nt.logger.Info(&quot;NATS reconnected&quot;)&#10;&#9;&#9;}),&#10;&#9;}&#10;&#10;&#9;conn, err := nats.Connect(cfg.URL, opts...)&#10;&#9;if err != nil {&#10;&#9;&#9;return fmt.Errorf(&quot;failed to connect to NATS: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;nt.conn = conn&#10;&#9;nt.logger.WithField(&quot;url&quot;, cfg.URL).Info(&quot;Connected to NATS server&quot;)&#10;&#10;&#9;// Initialize JetStream if stream is configured&#10;&#9;if cfg.Stream != &quot;&quot; {&#10;&#9;&#9;js, err := conn.JetStream()&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return fmt.Errorf(&quot;failed to get JetStream context: %w&quot;, err)&#10;&#9;&#9;}&#10;&#9;&#9;nt.js = js&#10;&#9;&#9;nt.logger.WithField(&quot;stream&quot;, cfg.Stream).Info(&quot;JetStream initialized&quot;)&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;&#10;// Disconnect closes the NATS connection&#10;func (nt *NATSTransport) Disconnect(ctx context.Context) error {&#10;&#9;nt.mu.Lock()&#10;&#9;defer nt.mu.Unlock()&#10;&#10;&#9;if nt.conn != nil {&#10;&#9;&#9;nt.conn.Close()&#10;&#9;&#9;nt.conn = nil&#10;&#9;&#9;nt.logger.Info(&quot;Disconnected from NATS server&quot;)&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;&#10;// Send sends a message to a specific subject&#10;func (nt *NATSTransport) Send(ctx context.Context, subject string, message *transport.Message) error {&#10;&#9;if !nt.IsConnected() {&#10;&#9;&#9;return fmt.Errorf(&quot;not connected to NATS&quot;)&#10;&#9;}&#10;&#10;&#9;data, err := json.Marshal(message)&#10;&#9;if err != nil {&#10;&#9;&#9;return fmt.Errorf(&quot;failed to marshal message: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;err = nt.conn.Publish(subject, data)&#10;&#9;if err != nil {&#10;&#9;&#9;return fmt.Errorf(&quot;failed to publish message: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;nt.logger.WithFields(logrus.Fields{&#10;&#9;&#9;&quot;subject&quot;:    subject,&#10;&#9;&#9;&quot;message_id&quot;: message.ID,&#10;&#9;}).Debug(&quot;Message sent&quot;)&#10;&#10;&#9;return nil&#10;}&#10;&#10;// Subscribe subscribes to a subject and returns a channel for receiving messages&#10;func (nt *NATSTransport) Subscribe(ctx context.Context, subject string) (&lt;-chan *transport.Message, error) {&#10;&#9;if !nt.IsConnected() {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;not connected to NATS&quot;)&#10;&#9;}&#10;&#10;&#9;// Check if already subscribed&#10;&#9;nt.mu.RLock()&#10;&#9;if _, exists := nt.subs[subject]; exists {&#10;&#9;&#9;nt.mu.RUnlock()&#10;&#9;&#9;return nil, fmt.Errorf(&quot;already subscribed to subject: %s&quot;, subject)&#10;&#9;}&#10;&#9;nt.mu.RUnlock()&#10;&#10;&#9;// Create subscription&#10;&#9;sub, err := nt.conn.Subscribe(subject, func(msg *nats.Msg) {&#10;&#9;&#9;var transportMsg transport.Message&#10;&#9;&#9;if err := json.Unmarshal(msg.Data, &amp;transportMsg); err != nil {&#10;&#9;&#9;&#9;nt.logger.WithError(err).Error(&quot;Failed to unmarshal message&quot;)&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#9;&#9;transportMsg.Reply = msg.Reply&#10;&#10;&#9;&#9;select {&#10;&#9;&#9;case nt.msgChan &lt;- &amp;transportMsg:&#10;&#9;&#9;case &lt;-ctx.Done():&#10;&#9;&#9;&#9;nt.logger.Debug(&quot;Context cancelled, dropping message&quot;)&#10;&#9;&#9;default:&#10;&#9;&#9;&#9;nt.logger.Warn(&quot;Message channel full, dropping message&quot;)&#10;&#9;&#9;}&#10;&#9;})&#10;&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;failed to subscribe: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;// Store subscription&#10;&#9;nt.mu.Lock()&#10;&#9;nt.subs[subject] = sub&#10;&#9;nt.mu.Unlock()&#10;&#10;&#9;nt.logger.WithField(&quot;subject&quot;, subject).Info(&quot;Subscribed to subject&quot;)&#10;&#10;&#9;return nt.msgChan, nil&#10;}&#10;&#10;// Request sends a request and waits for a response&#10;func (nt *NATSTransport) Request(ctx context.Context, subject string, message *transport.Message) (*transport.Message, error) {&#10;&#9;if !nt.IsConnected() {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;not connected to NATS&quot;)&#10;&#9;}&#10;&#10;&#9;data, err := json.Marshal(message)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;failed to marshal message: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;// Send request with timeout&#10;&#9;timeout := nt.config.Timeout&#10;&#9;if timeout == 0 {&#10;&#9;&#9;timeout = 30 * time.Second&#10;&#9;}&#10;&#10;&#9;response, err := nt.conn.Request(subject, data, timeout)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;request failed: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;var transportMsg transport.Message&#10;&#9;if err := json.Unmarshal(response.Data, &amp;transportMsg); err != nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;failed to unmarshal response: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;nt.logger.WithFields(logrus.Fields{&#10;&#9;&#9;&quot;subject&quot;:    subject,&#10;&#9;&#9;&quot;message_id&quot;: message.ID,&#10;&#9;}).Debug(&quot;Request completed&quot;)&#10;&#10;&#9;return &amp;transportMsg, nil&#10;}&#10;&#10;// Publish publishes a message to a subject (fire and forget)&#10;func (nt *NATSTransport) Publish(ctx context.Context, subject string, message *transport.Message) error {&#10;&#9;return nt.Send(ctx, subject, message)&#10;}&#10;&#10;// Close closes the transport and cleans up resources&#10;func (nt *NATSTransport) Close() error {&#10;&#9;nt.mu.Lock()&#10;&#9;defer nt.mu.Unlock()&#10;&#10;&#9;// Unsubscribe from all subjects&#10;&#9;for subject, sub := range nt.subs {&#10;&#9;&#9;sub.Unsubscribe()&#10;&#9;&#9;nt.logger.WithField(&quot;subject&quot;, subject).Debug(&quot;Unsubscribed from subject&quot;)&#10;&#9;}&#10;&#9;nt.subs = make(map[string]*nats.Subscription)&#10;&#10;&#9;// Close connection&#10;&#9;if nt.conn != nil {&#10;&#9;&#9;nt.conn.Close()&#10;&#9;&#9;nt.conn = nil&#10;&#9;}&#10;&#10;&#9;// Close message channel&#10;&#9;close(nt.msgChan)&#10;&#10;&#9;nt.logger.Info(&quot;NATS transport closed&quot;)&#10;&#9;return nil&#10;}&#10;&#10;// IsConnected returns true if the transport is connected&#10;func (nt *NATSTransport) IsConnected() bool {&#10;&#9;nt.mu.RLock()&#10;&#9;defer nt.mu.RUnlock()&#10;&#9;return nt.conn != nil &amp;&amp; nt.conn.IsConnected()&#10;}&#10;&#10;// NATSConn is a net.Conn implementation for a NATS-based connection&#10;type NATSConn struct {&#10;&#9;transport  *NATSTransport&#10;&#9;id         string&#10;&#9;localAddr  net.Addr&#10;&#9;remoteAddr net.Addr&#10;&#9;readCh     chan []byte&#10;&#9;closeCh    chan struct{}&#10;&#9;closed     bool&#10;&#9;mu         sync.Mutex&#10;}&#10;&#10;func (c *NATSConn) Read(b []byte) (n int, err error) {&#10;&#9;select {&#10;&#9;case data := &lt;-c.readCh:&#10;&#9;&#9;n = copy(b, data)&#10;&#9;&#9;return n, nil&#10;&#9;case &lt;-c.closeCh:&#10;&#9;&#9;return 0, io.EOF&#10;&#9;}&#10;}&#10;&#10;func (c *NATSConn) Write(b []byte) (n int, err error) {&#10;&#9;c.mu.Lock()&#10;&#9;defer c.mu.Unlock()&#10;&#9;if c.closed {&#10;&#9;&#9;return 0, io.ErrClosedPipe&#10;&#9;}&#10;&#10;&#9;msg := &amp;transport.Message{&#10;&#9;&#9;ID:   c.id,&#10;&#9;&#9;Data: b,&#10;&#9;}&#10;&#10;&#9;// The subject should be something like &quot;p.data.{connID}&quot;&#10;&#9;subject := &quot;p.data.&quot; + c.id&#10;&#9;err = c.transport.Publish(context.Background(), subject, msg)&#10;&#9;if err != nil {&#10;&#9;&#9;return 0, err&#10;&#9;}&#10;&#9;return len(b), nil&#10;}&#10;&#10;func (c *NATSConn) Close() error {&#10;&#9;c.mu.Lock()&#10;&#9;defer c.mu.Unlock()&#10;&#9;if c.closed {&#10;&#9;&#9;return nil&#10;&#9;}&#10;&#9;c.closed = true&#10;&#9;close(c.closeCh)&#10;&#9;// Also need to notify the other side&#10;&#9;return nil&#10;}&#10;&#10;func (c *NATSConn) LocalAddr() net.Addr {&#10;&#9;return c.localAddr&#10;}&#10;&#10;func (c *NATSConn) RemoteAddr() net.Addr {&#10;&#9;return c.remoteAddr&#10;}&#10;&#10;func (c *NATSConn) SetDeadline(t time.Time) error {&#10;&#9;return nil // Not implemented&#10;}&#10;&#10;func (c *NATSConn) SetReadDeadline(t time.Time) error {&#10;&#9;return nil // Not implemented&#10;}&#10;&#10;func (c *NATSConn) SetWriteDeadline(t time.Time) error {&#10;&#9;return nil // Not implemented&#10;}&#10;&#10;func (nt *NATSTransport) Dial(ctx context.Context, proxyAddr, remoteAddr string) (net.Conn, error) {&#10;&#9;host, port, err := net.SplitHostPort(remoteAddr)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;invalid remote address: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;reqMsg := &amp;transport.Message{&#10;&#9;&#9;Metadata: map[string]string{&#10;&#9;&#9;&#9;&quot;remote_host&quot;: host,&#10;&#9;&#9;&#9;&quot;remote_port&quot;: port,&#10;&#9;&#9;},&#10;&#9;}&#10;&#10;&#9;// The server listens on &quot;proxy.request&quot;&#10;&#9;subject := &quot;proxy.request&quot;&#10;&#10;&#9;respMsg, err := nt.Request(ctx, subject, reqMsg)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;failed to request proxy connection: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;connID := string(respMsg.Data)&#10;&#10;&#9;// Create a NATSConn&#10;&#9;conn := &amp;NATSConn{&#10;&#9;&#9;transport:  nt,&#10;&#9;&#9;id:         connID,&#10;&#9;&#9;readCh:     make(chan []byte, 100),&#10;&#9;&#9;closeCh:    make(chan struct{}),&#10;&#9;&#9;localAddr:  &amp;net.TCPAddr{IP: net.ParseIP(&quot;127.0.0.1&quot;), Port: 0}, // Dummy addr&#10;&#9;&#9;remoteAddr: &amp;net.TCPAddr{IP: net.ParseIP(&quot;127.0.0.1&quot;), Port: 0}, // Dummy addr&#10;&#9;}&#10;&#10;&#9;// Subscribe to data messages for this connection&#10;&#9;dataSubject := &quot;p.data.to_client.&quot; + connID&#10;&#9;sub, err := nt.conn.Subscribe(dataSubject, func(msg *nats.Msg) {&#10;&#9;&#9;var transportMsg transport.Message&#10;&#9;&#9;if err := json.Unmarshal(msg.Data, &amp;transportMsg); err != nil {&#10;&#9;&#9;&#9;nt.logger.WithError(err).Error(&quot;Failed to unmarshal message&quot;)&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#9;&#9;conn.readCh &lt;- transportMsg.Data&#10;&#9;})&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;failed to subscribe to data subject: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;// When connection is closed, unsubscribe&#10;&#9;go func() {&#10;&#9;&#9;&lt;-conn.closeCh&#10;&#9;&#9;sub.Unsubscribe()&#10;&#9;}()&#10;&#10;&#9;return conn, nil&#10;}&#10;&#10;func (nt *NATSTransport) Proxy(dst io.Writer, src io.Reader) (int64, error) {&#10;&#9;return io.Copy(dst, src)&#10;}&#10;" />
              <option name="updatedContent" value="package transport&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;encoding/json&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;io&quot;&#10;&#9;&quot;net&quot;&#10;&#9;&quot;sync&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;github.com/igorrius/tcp-sproxy/pkg/transport&quot;&#10;&#9;&quot;github.com/nats-io/nats.go&quot;&#10;&#9;&quot;github.com/sirupsen/logrus&quot;&#10;)&#10;&#10;// NATSTransport implements the Transport interface using NATS&#10;type NATSTransport struct {&#10;&#9;conn    *nats.Conn&#10;&#9;js      nats.JetStreamContext&#10;&#9;config  *NATSConfig&#10;&#9;logger  *logrus.Entry&#10;&#9;mu      sync.RWMutex&#10;&#9;subs    map[string]*nats.Subscription&#10;&#9;msgChan chan *transport.Message&#10;}&#10;&#10;// NATSConfig represents NATS-specific configuration&#10;type NATSConfig struct {&#10;&#9;URL     string            `json:&quot;url&quot;`&#10;&#9;Options map[string]string `json:&quot;options&quot;`&#10;&#9;Timeout time.Duration     `json:&quot;timeout&quot;`&#10;&#9;Retries int               `json:&quot;retries&quot;`&#10;&#9;Stream  string            `json:&quot;stream&quot;`&#10;&#9;Subject string            `json:&quot;subject&quot;`&#10;}&#10;&#10;// NewNATSTransport creates a new NATS transport instance&#10;func NewNATSTransport(logger *logrus.Entry) *NATSTransport {&#10;&#9;return &amp;NATSTransport{&#10;&#9;&#9;subs:    make(map[string]*nats.Subscription),&#10;&#9;&#9;msgChan: make(chan *transport.Message, 100),&#10;&#9;&#9;logger:  logger,&#10;&#9;}&#10;}&#10;&#10;// Connect establishes a connection to NATS server&#10;func (nt *NATSTransport) Connect(ctx context.Context, config interface{}) error {&#10;&#9;nt.mu.Lock()&#10;&#9;defer nt.mu.Unlock()&#10;&#10;&#9;cfg, ok := config.(*NATSConfig)&#10;&#9;if !ok {&#10;&#9;&#9;return fmt.Errorf(&quot;invalid config type for NATS transport&quot;)&#10;&#9;}&#10;&#9;nt.config = cfg&#10;&#10;&#9;// Set default timeout if not provided&#10;&#9;if cfg.Timeout == 0 {&#10;&#9;&#9;cfg.Timeout = 30 * time.Second&#10;&#9;}&#10;&#10;&#9;// Connect to NATS&#10;&#9;opts := []nats.Option{&#10;&#9;&#9;nats.Timeout(cfg.Timeout),&#10;&#9;&#9;nats.ReconnectWait(1 * time.Second),&#10;&#9;&#9;nats.MaxReconnects(-1), // Unlimited reconnects&#10;&#9;&#9;nats.DisconnectErrHandler(func(nc *nats.Conn, err error) {&#10;&#9;&#9;&#9;nt.logger.WithError(err).Warn(&quot;NATS disconnected&quot;)&#10;&#9;&#9;}),&#10;&#9;&#9;nats.ReconnectHandler(func(nc *nats.Conn) {&#10;&#9;&#9;&#9;nt.logger.Info(&quot;NATS reconnected&quot;)&#10;&#9;&#9;}),&#10;&#9;}&#10;&#10;&#9;conn, err := nats.Connect(cfg.URL, opts...)&#10;&#9;if err != nil {&#10;&#9;&#9;return fmt.Errorf(&quot;failed to connect to NATS: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;nt.conn = conn&#10;&#9;nt.logger.WithField(&quot;url&quot;, cfg.URL).Info(&quot;Connected to NATS server&quot;)&#10;&#10;&#9;// Initialize JetStream if stream is configured&#10;&#9;if cfg.Stream != &quot;&quot; {&#10;&#9;&#9;js, err := conn.JetStream()&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return fmt.Errorf(&quot;failed to get JetStream context: %w&quot;, err)&#10;&#9;&#9;}&#10;&#9;&#9;nt.js = js&#10;&#9;&#9;nt.logger.WithField(&quot;stream&quot;, cfg.Stream).Info(&quot;JetStream initialized&quot;)&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;&#10;// Disconnect closes the NATS connection&#10;func (nt *NATSTransport) Disconnect(ctx context.Context) error {&#10;&#9;nt.mu.Lock()&#10;&#9;defer nt.mu.Unlock()&#10;&#10;&#9;if nt.conn != nil {&#10;&#9;&#9;nt.conn.Close()&#10;&#9;&#9;nt.conn = nil&#10;&#9;&#9;nt.logger.Info(&quot;Disconnected from NATS server&quot;)&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;&#10;// Send sends a message to a specific subject&#10;func (nt *NATSTransport) Send(ctx context.Context, subject string, message *transport.Message) error {&#10;&#9;if !nt.IsConnected() {&#10;&#9;&#9;return fmt.Errorf(&quot;not connected to NATS&quot;)&#10;&#9;}&#10;&#10;&#9;data, err := json.Marshal(message)&#10;&#9;if err != nil {&#10;&#9;&#9;return fmt.Errorf(&quot;failed to marshal message: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;err = nt.conn.Publish(subject, data)&#10;&#9;if err != nil {&#10;&#9;&#9;return fmt.Errorf(&quot;failed to publish message: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;nt.logger.WithFields(logrus.Fields{&#10;&#9;&#9;&quot;subject&quot;:    subject,&#10;&#9;&#9;&quot;message_id&quot;: message.ID,&#10;&#9;}).Debug(&quot;Message sent&quot;)&#10;&#10;&#9;return nil&#10;}&#10;&#10;// Subscribe subscribes to a subject and returns a channel for receiving messages&#10;func (nt *NATSTransport) Subscribe(ctx context.Context, subject string) (&lt;-chan *transport.Message, error) {&#10;&#9;if !nt.IsConnected() {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;not connected to NATS&quot;)&#10;&#9;}&#10;&#10;&#9;// Check if already subscribed&#10;&#9;nt.mu.RLock()&#10;&#9;if _, exists := nt.subs[subject]; exists {&#10;&#9;&#9;nt.mu.RUnlock()&#10;&#9;&#9;return nil, fmt.Errorf(&quot;already subscribed to subject: %s&quot;, subject)&#10;&#9;}&#10;&#9;nt.mu.RUnlock()&#10;&#10;&#9;// Create subscription&#10;&#9;sub, err := nt.conn.Subscribe(subject, func(msg *nats.Msg) {&#10;&#9;&#9;var transportMsg transport.Message&#10;&#9;&#9;if err := json.Unmarshal(msg.Data, &amp;transportMsg); err != nil {&#10;&#9;&#9;&#9;nt.logger.WithError(err).Error(&quot;Failed to unmarshal message&quot;)&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#9;&#9;transportMsg.Reply = msg.Reply&#10;&#10;&#9;&#9;// Manually decode headers if they exist&#10;&#9;&#9;if msg.Header != nil {&#10;&#9;&#9;&#9;meta := make(map[string]string)&#10;&#9;&#9;&#9;for key, values := range msg.Header {&#10;&#9;&#9;&#9;&#9;if len(values) &gt; 0 {&#10;&#9;&#9;&#9;&#9;&#9;meta[key] = values[0]&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;transportMsg.Metadata = meta&#10;&#9;&#9;}&#10;&#10;&#9;&#9;select {&#10;&#9;&#9;case nt.msgChan &lt;- &amp;transportMsg:&#10;&#9;&#9;case &lt;-ctx.Done():&#10;&#9;&#9;&#9;nt.logger.Debug(&quot;Context cancelled, dropping message&quot;)&#10;&#9;&#9;default:&#10;&#9;&#9;&#9;nt.logger.Warn(&quot;Message channel full, dropping message&quot;)&#10;&#9;&#9;}&#10;&#9;})&#10;&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;failed to subscribe: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;// Store subscription&#10;&#9;nt.mu.Lock()&#10;&#9;nt.subs[subject] = sub&#10;&#9;nt.mu.Unlock()&#10;&#10;&#9;nt.logger.WithField(&quot;subject&quot;, subject).Info(&quot;Subscribed to subject&quot;)&#10;&#10;&#9;return nt.msgChan, nil&#10;}&#10;&#10;// Request sends a request and waits for a response&#10;func (nt *NATSTransport) Request(ctx context.Context, subject string, message *transport.Message) (*transport.Message, error) {&#10;&#9;if !nt.IsConnected() {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;not connected to NATS&quot;)&#10;&#9;}&#10;&#10;&#9;data, err := json.Marshal(message)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;failed to marshal message: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;// Create a NATS message and set headers from metadata&#10;&#9;natsMsg := nats.NewMsg(subject)&#10;&#9;natsMsg.Data = data&#10;&#9;if message.Metadata != nil {&#10;&#9;&#9;natsMsg.Header = make(nats.Header)&#10;&#9;&#9;for k, v := range message.Metadata {&#10;&#9;&#9;&#9;natsMsg.Header.Set(k, v)&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;// Send request with timeout&#10;&#9;timeout := nt.config.Timeout&#10;&#9;if timeout == 0 {&#10;&#9;&#9;timeout = 30 * time.Second&#10;&#9;}&#10;&#10;&#9;response, err := nt.conn.RequestMsg(natsMsg, timeout)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;request failed: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;var transportMsg transport.Message&#10;&#9;if err := json.Unmarshal(response.Data, &amp;transportMsg); err != nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;failed to unmarshal response: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;nt.logger.WithFields(logrus.Fields{&#10;&#9;&#9;&quot;subject&quot;:    subject,&#10;&#9;&#9;&quot;message_id&quot;: message.ID,&#10;&#9;}).Debug(&quot;Request completed&quot;)&#10;&#10;&#9;return &amp;transportMsg, nil&#10;}&#10;&#10;// Publish publishes a message to a subject (fire and forget)&#10;func (nt *NATSTransport) Publish(ctx context.Context, subject string, message *transport.Message) error {&#10;&#9;return nt.Send(ctx, subject, message)&#10;}&#10;&#10;// Close closes the transport and cleans up resources&#10;func (nt *NATSTransport) Close() error {&#10;&#9;nt.mu.Lock()&#10;&#9;defer nt.mu.Unlock()&#10;&#10;&#9;// Unsubscribe from all subjects&#10;&#9;for subject, sub := range nt.subs {&#10;&#9;&#9;sub.Unsubscribe()&#10;&#9;&#9;nt.logger.WithField(&quot;subject&quot;, subject).Debug(&quot;Unsubscribed from subject&quot;)&#10;&#9;}&#10;&#9;nt.subs = make(map[string]*nats.Subscription)&#10;&#10;&#9;// Close connection&#10;&#9;if nt.conn != nil {&#10;&#9;&#9;nt.conn.Close()&#10;&#9;&#9;nt.conn = nil&#10;&#9;}&#10;&#10;&#9;// Close message channel&#10;&#9;close(nt.msgChan)&#10;&#10;&#9;nt.logger.Info(&quot;NATS transport closed&quot;)&#10;&#9;return nil&#10;}&#10;&#10;// IsConnected returns true if the transport is connected&#10;func (nt *NATSTransport) IsConnected() bool {&#10;&#9;nt.mu.RLock()&#10;&#9;defer nt.mu.RUnlock()&#10;&#9;return nt.conn != nil &amp;&amp; nt.conn.IsConnected()&#10;}&#10;&#10;// NATSConn is a net.Conn implementation for a NATS-based connection&#10;type NATSConn struct {&#10;&#9;transport  *NATSTransport&#10;&#9;id         string&#10;&#9;localAddr  net.Addr&#10;&#9;remoteAddr net.Addr&#10;&#9;readCh     chan []byte&#10;&#9;closeCh    chan struct{}&#10;&#9;closed     bool&#10;&#9;mu         sync.Mutex&#10;}&#10;&#10;func (c *NATSConn) Read(b []byte) (n int, err error) {&#10;&#9;select {&#10;&#9;case data := &lt;-c.readCh:&#10;&#9;&#9;n = copy(b, data)&#10;&#9;&#9;return n, nil&#10;&#9;case &lt;-c.closeCh:&#10;&#9;&#9;return 0, io.EOF&#10;&#9;}&#10;}&#10;&#10;func (c *NATSConn) Write(b []byte) (n int, err error) {&#10;&#9;c.mu.Lock()&#10;&#9;defer c.mu.Unlock()&#10;&#9;if c.closed {&#10;&#9;&#9;return 0, io.ErrClosedPipe&#10;&#9;}&#10;&#10;&#9;msg := &amp;transport.Message{&#10;&#9;&#9;ID:   c.id,&#10;&#9;&#9;Data: b,&#10;&#9;}&#10;&#10;&#9;// The subject should be something like &quot;p.data.to_server.{connID}&quot;&#10;&#9;subject := &quot;p.data.to_server.&quot; + c.id&#10;&#9;err = c.transport.Publish(context.Background(), subject, msg)&#10;&#9;if err != nil {&#10;&#9;&#9;return 0, err&#10;&#9;}&#10;&#9;return len(b), nil&#10;}&#10;&#10;func (c *NATSConn) Close() error {&#10;&#9;c.mu.Lock()&#10;&#9;defer c.mu.Unlock()&#10;&#9;if c.closed {&#10;&#9;&#9;return nil&#10;&#9;}&#10;&#9;c.closed = true&#10;&#9;close(c.closeCh)&#10;&#9;// Also need to notify the other side&#10;&#9;return nil&#10;}&#10;&#10;func (c *NATSConn) LocalAddr() net.Addr {&#10;&#9;return c.localAddr&#10;}&#10;&#10;func (c *NATSConn) RemoteAddr() net.Addr {&#10;&#9;return c.remoteAddr&#10;}&#10;&#10;func (c *NATSConn) SetDeadline(t time.Time) error {&#10;&#9;return nil // Not implemented&#10;}&#10;&#10;func (c *NATSConn) SetReadDeadline(t time.Time) error {&#10;&#9;return nil // Not implemented&#10;}&#10;&#10;func (c *NATSConn) SetWriteDeadline(t time.Time) error {&#10;&#9;return nil // Not implemented&#10;}&#10;&#10;func (nt *NATSTransport) Dial(ctx context.Context, proxyAddr, remoteAddr string) (net.Conn, error) {&#10;&#9;host, port, err := net.SplitHostPort(remoteAddr)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;invalid remote address: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;reqMsg := &amp;transport.Message{&#10;&#9;&#9;Metadata: map[string]string{&#10;&#9;&#9;&#9;&quot;remote_host&quot;: host,&#10;&#9;&#9;&#9;&quot;remote_port&quot;: port,&#10;&#9;&#9;},&#10;&#9;}&#10;&#10;&#9;// The server listens on &quot;proxy.request&quot;&#10;&#9;subject := &quot;proxy.request&quot;&#10;&#10;&#9;respMsg, err := nt.Request(ctx, subject, reqMsg)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;failed to request proxy connection: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;connID := string(respMsg.Data)&#10;&#10;&#9;// Create a NATSConn&#10;&#9;conn := &amp;NATSConn{&#10;&#9;&#9;transport:  nt,&#10;&#9;&#9;id:         connID,&#10;&#9;&#9;readCh:     make(chan []byte, 100),&#10;&#9;&#9;closeCh:    make(chan struct{}),&#10;&#9;&#9;localAddr:  &amp;net.TCPAddr{IP: net.ParseIP(&quot;127.0.0.1&quot;), Port: 0}, // Dummy addr&#10;&#9;&#9;remoteAddr: &amp;net.TCPAddr{IP: net.ParseIP(&quot;127.0.0.1&quot;), Port: 0}, // Dummy addr&#10;&#9;}&#10;&#10;&#9;// Subscribe to data messages for this connection&#10;&#9;dataSubject := &quot;p.data.to_client.&quot; + connID&#10;&#9;sub, err := nt.conn.Subscribe(dataSubject, func(msg *nats.Msg) {&#10;&#9;&#9;var transportMsg transport.Message&#10;&#9;&#9;if err := json.Unmarshal(msg.Data, &amp;transportMsg); err != nil {&#10;&#9;&#9;&#9;nt.logger.WithError(err).Error(&quot;Failed to unmarshal message&quot;)&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#9;&#9;conn.readCh &lt;- transportMsg.Data&#10;&#9;})&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;failed to subscribe to data subject: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;// When connection is closed, unsubscribe&#10;&#9;go func() {&#10;&#9;&#9;&lt;-conn.closeCh&#10;&#9;&#9;sub.Unsubscribe()&#10;&#10;&#9;&#9;// Also send a close notification to the server&#10;&#9;&#9;closeMsg := &amp;transport.Message{&#10;&#9;&#9;&#9;ID:       conn.id,&#10;&#9;&#9;&#9;Metadata: map[string]string{&quot;type&quot;: &quot;close&quot;},&#10;&#9;&#9;}&#10;&#9;&#9;closeSubject := &quot;p.data.to_server.&quot; + conn.id&#10;&#9;&#9;nt.Publish(context.Background(), closeSubject, closeMsg)&#10;&#9;}()&#10;&#10;&#9;return conn, nil&#10;}&#10;&#10;func (nt *NATSTransport) Proxy(dst io.Writer, src io.Reader) (int64, error) {&#10;&#9;return io.Copy(dst, src)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/pkg/transport/transport.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/pkg/transport/transport.go" />
              <option name="originalContent" value="package transport&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;)&#10;&#10;// Message represents a transport message&#10;type Message struct {&#10;&#9;ID       string&#10;&#9;Data     []byte&#10;&#9;Metadata map[string]string&#10;}&#10;&#10;// Transport defines the interface for abstract transport layer&#10;type Transport interface {&#10;&#9;// Connect establishes a connection to the transport layer&#10;&#9;Connect(ctx context.Context, config interface{}) error&#10;&#10;&#9;// Disconnect closes the transport connection&#10;&#9;Disconnect(ctx context.Context) error&#10;&#10;&#9;// Send sends a message to a specific subject/topic&#10;&#9;Send(ctx context.Context, subject string, message *Message) error&#10;&#10;&#9;// Subscribe subscribes to a subject/topic and returns a channel for receiving messages&#10;&#9;Subscribe(ctx context.Context, subject string) (&lt;-chan *Message, error)&#10;&#10;&#9;// Request sends a request and waits for a response&#10;&#9;Request(ctx context.Context, subject string, message *Message) (*Message, error)&#10;&#10;&#9;// Publish publishes a message to a subject/topic (fire and forget)&#10;&#9;Publish(ctx context.Context, subject string, message *Message) error&#10;&#10;&#9;// Close closes the transport&#10;&#9;Close() error&#10;&#10;&#9;// IsConnected returns true if the transport is connected&#10;&#9;IsConnected() bool&#10;}&#10;&#10;// TransportConfig represents configuration for transport&#10;type TransportConfig struct {&#10;&#9;URL     string            `json:&quot;url&quot;`&#10;&#9;Options map[string]string `json:&quot;options&quot;`&#10;&#9;Timeout int               `json:&quot;timeout&quot;`&#10;&#9;Retries int               `json:&quot;retries&quot;`&#10;}&#10;&#10;// NewMessage creates a new transport message&#10;func NewMessage(id string, data []byte) *Message {&#10;&#9;return &amp;Message{&#10;&#9;&#9;ID:       id,&#10;&#9;&#9;Data:     data,&#10;&#9;&#9;Metadata: make(map[string]string),&#10;&#9;}&#10;}&#10;&#10;// NewMessageWithMetadata creates a new transport message with metadata&#10;func NewMessageWithMetadata(id string, data []byte, metadata map[string]string) *Message {&#10;&#9;return &amp;Message{&#10;&#9;&#9;ID:       id,&#10;&#9;&#9;Data:     data,&#10;&#9;&#9;Metadata: metadata,&#10;&#9;}&#10;}&#10;" />
              <option name="updatedContent" value="package transport&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;)&#10;&#10;// Message represents a transport message&#10;type Message struct {&#10;&#9;ID       string&#10;&#9;Reply    string&#10;&#9;Data     []byte&#10;&#9;Metadata map[string]string&#10;}&#10;&#10;// Transport defines the interface for abstract transport layer&#10;type Transport interface {&#10;&#9;// Connect establishes a connection to the transport layer&#10;&#9;Connect(ctx context.Context, config interface{}) error&#10;&#10;&#9;// Disconnect closes the transport connection&#10;&#9;Disconnect(ctx context.Context) error&#10;&#10;&#9;// Send sends a message to a specific subject/topic&#10;&#9;Send(ctx context.Context, subject string, message *Message) error&#10;&#10;&#9;// Subscribe subscribes to a subject/topic and returns a channel for receiving messages&#10;&#9;Subscribe(ctx context.Context, subject string) (&lt;-chan *Message, error)&#10;&#10;&#9;// Request sends a request and waits for a response&#10;&#9;Request(ctx context.Context, subject string, message *Message) (*Message, error)&#10;&#10;&#9;// Publish publishes a message to a subject/topic (fire and forget)&#10;&#9;Publish(ctx context.Context, subject string, message *Message) error&#10;&#10;&#9;// Close closes the transport&#10;&#9;Close() error&#10;&#10;&#9;// IsConnected returns true if the transport is connected&#10;&#9;IsConnected() bool&#10;}&#10;&#10;// TransportConfig represents configuration for transport&#10;type TransportConfig struct {&#10;&#9;URL     string            `json:&quot;url&quot;`&#10;&#9;Options map[string]string `json:&quot;options&quot;`&#10;&#9;Timeout int               `json:&quot;timeout&quot;`&#10;&#9;Retries int               `json:&quot;retries&quot;`&#10;}&#10;&#10;// NewMessage creates a new transport message&#10;func NewMessage(id string, data []byte) *Message {&#10;&#9;return &amp;Message{&#10;&#9;&#9;ID:       id,&#10;&#9;&#9;Data:     data,&#10;&#9;&#9;Metadata: make(map[string]string),&#10;&#9;}&#10;}&#10;&#10;// NewMessageWithMetadata creates a new transport message with metadata&#10;func NewMessageWithMetadata(id string, data []byte, metadata map[string]string) *Message {&#10;&#9;return &amp;Message{&#10;&#9;&#9;ID:       id,&#10;&#9;&#9;Data:     data,&#10;&#9;&#9;Metadata: metadata,&#10;&#9;}&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>