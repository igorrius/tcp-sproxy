<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/README.md" />
              <option name="originalContent" value="# NATS TCP Proxy&#10;&#10;A high-performance TCP proxy that uses NATS (Neural Autonomic Transport System) as the transport layer for proxying TCP connections between client and server.&#10;&#10;## Architecture&#10;&#10;This project follows Domain-Driven Design (DDD) methodology with a client-server architecture:&#10;&#10;### Domain Layer&#10;- **Entities**: Connection, ProxySession&#10;- **Value Objects**: ConnectionID, Port, Host&#10;- **Domain Services**: ProxyService&#10;- ** Repositories**: ConnectionRepository&#10;&#10;### Application Layer&#10;- **Use Cases**: ProxyConnection, ManageConnections&#10;- **Services**: Application services that orchestrate domain objects&#10;&#10;### Infrastructure Layer&#10;- **Transport**: NATS implementation of abstract transport interface&#10;- **Persistence**: In-memory connection storage&#10;- **Configuration**: Viper-based configuration management&#10;&#10;### Interface Layer&#10;- **CLI Commands**: Client and Server commands using Cobra&#10;- **APIs**: REST endpoints (future enhancement)&#10;&#10;## Client-Server Flow&#10;&#10;The proxy operates with a **dynamic worker model**:&#10;&#10;1. **Client** specifies the remote target (host:port) when starting&#10;2. **Client** listens on a local port and forwards connections through NATS&#10;3. **Server** receives NATS messages with remote target information&#10;4. **Server** creates separate internal workers for each connection&#10;5. **Workers** establish connections to the specified remote targets&#10;6. **Bidirectional data flow** occurs through NATS between client and server workers&#10;&#10;## Features&#10;&#10;- **Dynamic Worker Model**: Server creates separate workers for each connection&#10;- **Client-Specified Targets**: Remote host/port specified by client, not server&#10;- **Multi-Connection Support**: Handle multiple concurrent TCP connections&#10;- **Abstract Transport**: Pluggable transport layer (currently NATS)&#10;- **DDD Architecture**: Clean separation of concerns&#10;- **CLI Interface**: Easy-to-use command-line tools&#10;- **Configuration**: Flexible configuration management&#10;- **Logging**: Structured logging with logrus&#10;&#10;## Project Structure&#10;&#10;```&#10;nats-proxy/&#10;├── cmd/&#10;│   ├── client/          # Client CLI application&#10;│   └── server/          # Server CLI application&#10;├── internal/&#10;│   ├── domain/          # Domain layer (entities, value objects, services)&#10;│   ├── application/     # Application layer (use cases, services)&#10;│   ├── infrastructure/  # Infrastructure layer (transport, persistence)&#10;│   └── interfaces/      # Interface layer (CLI, APIs)&#10;├── pkg/&#10;│   └── transport/       # Abstract transport interface&#10;├── examples/            # Usage examples&#10;├── docs/               # Documentation&#10;└── scripts/            # Build and deployment scripts&#10;```&#10;&#10;## Quick Start&#10;&#10;### Prerequisites&#10;&#10;- Go 1.21 or higher&#10;- NATS server running (local or cloud)&#10;&#10;### Installation&#10;&#10;```bash&#10;go mod tidy&#10;go build ./cmd/client&#10;go build ./cmd/server&#10;```&#10;&#10;### Docker Deployment&#10;&#10;For production deployment, you can use Docker:&#10;&#10;```bash&#10;# Build and run server with Docker&#10;./scripts/docker-server.sh build&#10;./scripts/docker-server.sh run&#10;&#10;# Or use Docker Compose (includes NATS and Redis)&#10;./scripts/docker-server.sh compose&#10;```&#10;&#10;### Running the Server&#10;&#10;```bash&#10;./server --nats-url nats://localhost:4222&#10;```&#10;&#10;### Running the Client&#10;&#10;```bash&#10;./client --nats-url nats://localhost:4222 --local-port 6380 --remote-host localhost --remote-port 6379&#10;```&#10;&#10;## Configuration&#10;&#10;### Server Configuration&#10;&#10;- `--nats-url`: NATS server URL (default: nats://localhost:4222)&#10;- `--log-level`: Log level (debug, info, warn, error)&#10;&#10;### Client Configuration&#10;&#10;- `--nats-url`: NATS server URL (default: nats://localhost:4222)&#10;- `--local-port`: Local port to listen on&#10;- `--remote-host`: Target remote host&#10;- `--remote-port`: Target remote port&#10;- `--log-level`: Log level (debug, info, warn, error)&#10;&#10;## Examples&#10;&#10;### Redis Proxy Example&#10;&#10;1. Start NATS server:&#10;```bash&#10;nats-server&#10;```&#10;&#10;2. Start the proxy server (pointing to Redis):&#10;```bash&#10;./server --nats-url nats://localhost:4222 --remote-host localhost --remote-port 6379&#10;```&#10;&#10;3. Start the proxy client:&#10;```bash&#10;./client --nats-url nats://localhost:4222 --local-port 6380&#10;```&#10;&#10;4. Connect to Redis through the proxy:&#10;```bash&#10;redis-cli -p 6380&#10;```&#10;&#10;## Development&#10;&#10;### Building&#10;&#10;```bash&#10;make build&#10;```&#10;&#10;### Testing&#10;&#10;```bash&#10;make test&#10;```&#10;&#10;### Running Examples&#10;&#10;```bash&#10;make run-examples&#10;```&#10;&#10;### Docker Development&#10;&#10;```bash&#10;# Build server Docker image&#10;./scripts/docker-server.sh build&#10;&#10;# Run server container&#10;./scripts/docker-server.sh run&#10;&#10;# View logs&#10;./scripts/docker-server.sh logs&#10;&#10;# Stop container&#10;./scripts/docker-server.sh stop&#10;&#10;# Clean up&#10;./scripts/docker-server.sh clean&#10;```&#10;&#10;### Integration Testing&#10;&#10;```bash&#10;# Run full integration tests with cleanup&#10;make integration-test&#10;&#10;# Run quick integration test (no cleanup)&#10;make integration-test-quick&#10;&#10;# Or run directly with options&#10;./scripts/integration-test.sh -c -v&#10;&#10;# Run with custom TTL duration for TTL tests (default: 5 seconds)&#10;./scripts/integration-test.sh --ttl 10&#10;&#10;# Show all available options&#10;./scripts/integration-test.sh --help&#10;```&#10;&#10;The integration tests include comprehensive TTL (Time To Live) tests that verify:&#10;- Basic SETEX operations with expiration&#10;- EXPIRE command functionality&#10;- PERSIST command for removing TTL from keys&#10;&#10;These tests ensure that the proxy correctly handles Redis TTL operations, allowing applications to use expiring keys through the proxy.&#10;&#10;### GitHub Release&#10;&#10;```bash&#10;# Create a release (requires GitHub token)&#10;./scripts/github-release.sh -t v1.0.0 -g YOUR_GITHUB_TOKEN&#10;&#10;# Create a draft release&#10;./scripts/github-release.sh -t v1.0.0-rc1 -d -p&#10;&#10;# Skip tests for quick release&#10;./scripts/github-release.sh -t v1.0.0 -s&#10;```&#10;&#10;## Contributing&#10;&#10;1. Fork the repository&#10;2. Create a feature branch&#10;3. Make your changes&#10;4. Add tests&#10;5. Submit a pull request&#10;&#10;## License&#10;&#10;MIT License&#10;" />
              <option name="updatedContent" value="# NATS TCP Proxy&#10;&#10;A high-performance TCP proxy that uses NATS (Neural Autonomic Transport System) as the transport layer for proxying TCP connections between client and server.&#10;&#10;## Architecture&#10;&#10;This project follows Domain-Driven Design (DDD) methodology with a client-server architecture:&#10;&#10;### Domain Layer&#10;- **Entities**: Connection, ProxySession&#10;- **Value Objects**: ConnectionID, Port, Host&#10;- **Domain Services**: ProxyService&#10;- ** Repositories**: ConnectionRepository&#10;&#10;### Application Layer&#10;- **Use Cases**: ProxyConnection, ManageConnections&#10;- **Services**: Application services that orchestrate domain objects&#10;&#10;### Infrastructure Layer&#10;- **Transport**: NATS implementation of abstract transport interface&#10;- **Persistence**: In-memory connection storage&#10;- **Configuration**: Viper-based configuration management&#10;&#10;### Interface Layer&#10;- **CLI Commands**: Client and Server commands using Cobra&#10;- **APIs**: REST endpoints (future enhancement)&#10;&#10;## Client-Server Flow&#10;&#10;The proxy operates with a **dynamic worker model**:&#10;&#10;1. **Client** specifies the remote target (host:port) when starting&#10;2. **Client** listens on a local port and forwards connections through NATS&#10;3. **Server** receives NATS messages with remote target information&#10;4. **Server** creates separate internal workers for each connection&#10;5. **Workers** establish connections to the specified remote targets&#10;6. **Bidirectional data flow** occurs through NATS between client and server workers&#10;&#10;## Features&#10;&#10;- **Dynamic Worker Model**: Server creates separate workers for each connection&#10;- **Client-Specified Targets**: Remote host/port specified by client, not server&#10;- **Multi-Connection Support**: Handle multiple concurrent TCP connections&#10;- **Abstract Transport**: Pluggable transport layer (currently NATS)&#10;- **DDD Architecture**: Clean separation of concerns&#10;- **CLI Interface**: Easy-to-use command-line tools&#10;- **Configuration**: Flexible configuration management&#10;- **Logging**: Structured logging with logrus&#10;&#10;## Project Structure&#10;&#10;```&#10;nats-proxy/&#10;├── cmd/&#10;│   ├── client/          # Client CLI application&#10;│   └── server/          # Server CLI application&#10;├── internal/&#10;│   ├── domain/          # Domain layer (entities, value objects, services)&#10;│   ├── application/     # Application layer (use cases, services)&#10;│   ├── infrastructure/  # Infrastructure layer (transport, persistence)&#10;│   └── interfaces/      # Interface layer (CLI, APIs)&#10;├── pkg/&#10;│   └── transport/       # Abstract transport interface&#10;├── examples/            # Usage examples&#10;├── docs/               # Documentation&#10;└── scripts/            # Build and deployment scripts&#10;```&#10;&#10;## Quick Start&#10;&#10;### Prerequisites&#10;&#10;- Go 1.21 or higher&#10;- NATS server running (local or cloud)&#10;&#10;### Installation&#10;&#10;```bash&#10;go mod tidy&#10;go build ./cmd/client&#10;go build ./cmd/server&#10;```&#10;&#10;### Docker Deployment&#10;&#10;For production deployment, you can use Docker:&#10;&#10;```bash&#10;# Build and run server with Docker&#10;./scripts/docker-server.sh build&#10;./scripts/docker-server.sh run&#10;&#10;# Or use Docker Compose (includes NATS and Redis)&#10;./scripts/docker-server.sh compose&#10;```&#10;&#10;### Running the Server&#10;&#10;```bash&#10;./server --nats-url nats://localhost:4222&#10;```&#10;&#10;### Running the Client&#10;&#10;```bash&#10;./client --nats-url nats://localhost:4222 --local-port 6380 --remote-host localhost --remote-port 6379&#10;```&#10;&#10;## Configuration&#10;&#10;### Server Configuration&#10;&#10;- `--nats-url`: NATS server URL (default: nats://localhost:4222)&#10;- `--log-level`: Log level (debug, info, warn, error)&#10;&#10;### Client Configuration&#10;&#10;- `--nats-url`: NATS server URL (default: nats://localhost:4222)&#10;- `--local-port`: Local port to listen on&#10;- `--remote-host`: Target remote host&#10;- `--remote-port`: Target remote port&#10;- `--log-level`: Log level (debug, info, warn, error)&#10;&#10;## Examples&#10;&#10;### Redis Proxy Example&#10;&#10;1. Start NATS server:&#10;```bash&#10;nats-server&#10;```&#10;&#10;2. Start the proxy server (pointing to Redis):&#10;```bash&#10;./server --nats-url nats://localhost:4222 --remote-host localhost --remote-port 6379&#10;```&#10;&#10;3. Start the proxy client:&#10;```bash&#10;./client --nats-url nats://localhost:4222 --local-port 6380&#10;```&#10;&#10;4. Connect to Redis through the proxy:&#10;```bash&#10;redis-cli -p 6380&#10;```&#10;&#10;## Development&#10;&#10;### Building&#10;&#10;```bash&#10;make build&#10;```&#10;&#10;### Testing&#10;&#10;```bash&#10;make test&#10;```&#10;&#10;### Running Examples&#10;&#10;```bash&#10;make run-examples&#10;```&#10;&#10;### Docker Development&#10;&#10;```bash&#10;# Build server Docker image&#10;./scripts/docker-server.sh build&#10;&#10;# Run server container&#10;./scripts/docker-server.sh run&#10;&#10;# View logs&#10;./scripts/docker-server.sh logs&#10;&#10;# Stop container&#10;./scripts/docker-server.sh stop&#10;```&#10;&#10;### GitHub Release&#10;&#10;```bash&#10;# Create a release (requires GitHub token)&#10;./scripts/github-release.sh -t v1.0.0 -g YOUR_GITHUB_TOKEN&#10;&#10;# Create a draft release&#10;./scripts/github-release.sh -t v1.0.0-rc1 -d -p&#10;&#10;# Skip tests for quick release&#10;./scripts/github-release.sh -t v1.0.0 -s&#10;```&#10;&#10;## Contributing&#10;&#10;1. Fork the repository&#10;2. Create a feature branch&#10;3. Make your changes&#10;4. Add tests&#10;5. Submit a pull request&#10;&#10;## License&#10;&#10;MIT License" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/docs/architecture.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/docs/architecture.md" />
              <option name="originalContent" value="# NATS TCP Proxy - Architecture Documentation&#10;&#10;## Overview&#10;&#10;The NATS TCP Proxy is a high-performance TCP proxy that uses NATS (Neural Autonomic Transport System) as the transport layer for proxying TCP connections between client and server. The project follows Domain-Driven Design (DDD) methodology with a clean architecture approach.&#10;&#10;## Architecture Layers&#10;&#10;### 1. Domain Layer (`internal/domain/`)&#10;&#10;The domain layer contains the core business logic and is independent of external concerns.&#10;&#10;#### Entities (`internal/domain/entities/`)&#10;- **Connection**: Represents a TCP connection between client and server&#10;  - Properties: ID, ClientAddr, ServerAddr, CreatedAt, LastActivity, Status&#10;  - Methods: UpdateActivity(), SetStatus(), IsActive(), Close(), etc.&#10;&#10;#### Value Objects (`internal/domain/valueobjects/`)&#10;- **ConnectionID**: Unique identifier for connections&#10;  - Immutable and self-validating&#10;  - Methods: String(), Equals(), IsZero()&#10;&#10;#### Domain Services (`internal/domain/services/`)&#10;- **ProxyService**: Core business logic for handling proxy connections&#10;  - Methods: ProxyConnection(), GetConnectionStats(), CloseConnection()&#10;  - Handles bidirectional data flow between client and remote server&#10;&#10;#### Repositories (`internal/domain/repositories/`)&#10;- **ConnectionRepository**: Interface for connection persistence&#10;  - Methods: Store(), GetByID(), GetActive(), GetAll(), Update(), Delete(), Cleanup()&#10;&#10;### 2. Application Layer (`internal/application/`)&#10;&#10;The application layer orchestrates domain objects and implements use cases.&#10;&#10;#### Use Cases (`internal/application/usecases/`)&#10;- **ProxyUseCase**: Application logic for proxy operations&#10;  - Methods: HandleNewConnection(), GetConnectionStats(), CleanupOldConnections()&#10;  - Coordinates between domain services and infrastructure&#10;&#10;### 3. Infrastructure Layer (`internal/infrastructure/`)&#10;&#10;The infrastructure layer handles external concerns like transport and persistence.&#10;&#10;#### Transport (`internal/infrastructure/transport/`)&#10;- **NATSTransport**: NATS implementation of the abstract transport interface&#10;  - Handles connection to NATS server&#10;  - Manages message publishing/subscribing&#10;  - Implements request-reply pattern&#10;&#10;#### Repositories (`internal/infrastructure/repositories/`)&#10;- **InMemoryConnectionRepository**: In-memory implementation of ConnectionRepository&#10;  - Thread-safe connection storage&#10;  - Provides statistics and cleanup functionality&#10;&#10;### 4. Interface Layer (`cmd/`)&#10;&#10;The interface layer handles user interaction and external APIs.&#10;&#10;#### CLI Commands (`cmd/client/` and `cmd/server/`)&#10;- **Client**: Listens on local port and forwards connections through NATS&#10;- **Server**: Receives NATS messages and forwards to remote server&#10;- Both use Cobra for CLI framework and Viper for configuration&#10;&#10;## Transport Layer&#10;&#10;### Abstract Transport Interface (`pkg/transport/`)&#10;&#10;```go&#10;type Transport interface {&#10;    Connect(ctx context.Context, config interface{}) error&#10;    Disconnect(ctx context.Context) error&#10;    Send(ctx context.Context, subject string, message *Message) error&#10;    Subscribe(ctx context.Context, subject string) (&lt;-chan *Message, error)&#10;    Request(ctx context.Context, subject string, message *Message) (*Message, error)&#10;    Publish(ctx context.Context, subject string, message *Message) error&#10;    Close() error&#10;    IsConnected() bool&#10;}&#10;```&#10;&#10;### NATS Implementation&#10;&#10;The NATS transport implementation provides:&#10;- **Connection Management**: Automatic reconnection and error handling&#10;- **Message Serialization**: JSON-based message format&#10;- **Subject-based Routing**: Uses NATS subjects for message routing&#10;- **Request-Reply Pattern**: Supports synchronous request-response&#10;- **Publish-Subscribe**: Supports asynchronous message broadcasting&#10;&#10;## Data Flow&#10;&#10;### Client-Side Flow&#10;&#10;1. **Connection Acceptance**: Client listens on local port&#10;2. **NATS Connection**: Establishes connection to NATS server&#10;3. **Message Forwarding**: Reads from client connection and publishes to NATS with remote target info&#10;4. **Response Handling**: Subscribes to response subject and forwards to client&#10;&#10;### Server-Side Flow&#10;&#10;1. **NATS Subscription**: Subscribes to request subjects&#10;2. **Worker Creation**: Creates separate worker for each connection&#10;3. **Remote Connection**: Worker establishes connection to client-specified remote target&#10;4. **Data Forwarding**: Forwards data between NATS and remote server&#10;5. **Response Publishing**: Publishes responses back to NATS&#10;&#10;### Message Format&#10;&#10;```json&#10;{&#10;  &quot;id&quot;: &quot;connection_id&quot;,&#10;  &quot;data&quot;: &quot;base64_encoded_data&quot;,&#10;  &quot;metadata&quot;: {&#10;    &quot;response_subject&quot;: &quot;proxy.response.conn_id&quot;,&#10;    &quot;client_addr&quot;: &quot;127.0.0.1:54321&quot;,&#10;    &quot;remote_host&quot;: &quot;localhost&quot;,&#10;    &quot;remote_port&quot;: &quot;6379&quot;&#10;  }&#10;}&#10;```&#10;&#10;## Configuration&#10;&#10;### Server Configuration&#10;&#10;- `--nats-url`: NATS server URL (default: nats://localhost:4222)&#10;- `--remote-host`: Target remote host&#10;- `--remote-port`: Target remote port&#10;- `--listen-addr`: Address to listen on (default: :8080)&#10;- `--log-level`: Log level (debug, info, warn, error)&#10;&#10;### Client Configuration&#10;&#10;- `--nats-url`: NATS server URL (default: nats://localhost:4222)&#10;- `--local-port`: Local port to listen on&#10;- `--listen-addr`: Local address to listen on (default: localhost)&#10;- `--log-level`: Log level (debug, info, warn, error)&#10;&#10;## Error Handling&#10;&#10;### Connection Errors&#10;- **NATS Connection**: Automatic reconnection with exponential backoff&#10;- **Remote Connection**: Timeout handling and graceful degradation&#10;- **Client Connection**: Proper cleanup and resource management&#10;&#10;### Message Errors&#10;- **Serialization**: JSON marshaling/unmarshaling error handling&#10;- **Transport**: Network timeout and retry logic&#10;- **Validation**: Input validation and sanitization&#10;&#10;## Performance Considerations&#10;&#10;### Connection Management&#10;- **Connection Pooling**: Reuses connections where possible&#10;- **Timeout Handling**: 30-second timeouts prevent hanging connections&#10;- **Buffer Management**: 32KB buffers for efficient data transfer&#10;&#10;### Memory Management&#10;- **Garbage Collection**: Proper cleanup of closed connections&#10;- **Memory Leaks**: Regular cleanup of old connections&#10;- **Resource Limits**: Configurable limits for concurrent connections&#10;&#10;### Scalability&#10;- **Horizontal Scaling**: Multiple clients can connect to same server&#10;- **Load Balancing**: NATS can distribute load across multiple servers&#10;- **High Availability**: NATS clustering for fault tolerance&#10;&#10;## Security Considerations&#10;&#10;### Network Security&#10;- **TLS Support**: NATS supports TLS for encrypted communication&#10;- **Authentication**: NATS authentication and authorization&#10;- **Firewall**: Proper firewall configuration for proxy ports&#10;&#10;### Data Security&#10;- **Message Encryption**: Optional message encryption&#10;- **Access Control**: Port and IP-based access control&#10;- **Audit Logging**: Comprehensive logging for security auditing&#10;&#10;## Monitoring and Observability&#10;&#10;### Metrics&#10;- **Connection Count**: Active, closed, and error connections&#10;- **Data Transfer**: Bytes transferred in each direction&#10;- **Response Times**: Connection establishment and data transfer times&#10;&#10;### Logging&#10;- **Structured Logging**: JSON-formatted logs with correlation IDs&#10;- **Log Levels**: Configurable log levels for different environments&#10;- **Log Rotation**: Automatic log rotation and cleanup&#10;&#10;### Health Checks&#10;- **NATS Connectivity**: Regular health checks for NATS connection&#10;- **Remote Connectivity**: Health checks for remote server connection&#10;- **Resource Usage**: Memory and CPU usage monitoring&#10;&#10;## Deployment&#10;&#10;### Local Development&#10;```bash&#10;# Build the project&#10;make build&#10;&#10;# Start server&#10;./bin/server --nats-url nats://localhost:4222&#10;&#10;# Start client&#10;./bin/client --local-port 6380 --remote-host localhost --remote-port 6379&#10;```&#10;&#10;### Production Deployment&#10;1. **Containerization**: Docker images for easy deployment&#10;2. **Orchestration**: Kubernetes manifests for container orchestration&#10;3. **Service Discovery**: Integration with service discovery systems&#10;4. **Configuration Management**: Environment-based configuration&#10;&#10;### Docker Deployment&#10;&#10;The server can be deployed using Docker with the provided configuration:&#10;&#10;```bash&#10;# Build and run with Docker&#10;./scripts/docker-server.sh build&#10;./scripts/docker-server.sh run&#10;&#10;# Or use Docker Compose for full stack&#10;./scripts/docker-server.sh compose&#10;```&#10;&#10;**Docker Features:**&#10;- **Multi-stage build** for optimized image size&#10;- **Non-root user** for security&#10;- **Health checks** for monitoring&#10;- **Environment variables** for configuration&#10;- **Docker Compose** for complete stack deployment&#10;&#10;### High Availability&#10;1. **NATS Clustering**: Multiple NATS servers for redundancy&#10;2. **Load Balancing**: Multiple proxy servers behind load balancer&#10;3. **Health Checks**: Automated health checks and failover&#10;4. **Backup and Recovery**: Regular backups and disaster recovery&#10;&#10;## Testing Strategy&#10;&#10;### Unit Tests&#10;- **Domain Logic**: Tests for entities, value objects, and domain services&#10;- **Repository Tests**: Tests for data access layer&#10;- **Transport Tests**: Tests for NATS transport implementation&#10;&#10;### Integration Tests&#10;- **End-to-End**: Full proxy functionality tests&#10;- **NATS Integration**: Tests with real NATS server&#10;- **Performance Tests**: Load testing and performance benchmarks&#10;&#10;### Acceptance Tests&#10;- **Redis Proxy**: Complete Redis proxy scenario&#10;- **Multiple Connections**: Tests with multiple concurrent connections&#10;- **Error Scenarios**: Tests for various error conditions&#10;&#10;## Future Enhancements&#10;&#10;### Planned Features&#10;1. **Multiple Transport Support**: gRPC, WebSocket, and other transport layers&#10;2. **Protocol Support**: HTTP, HTTPS, and other protocols&#10;3. **Advanced Routing**: Content-based routing and load balancing&#10;4. **Metrics Integration**: Prometheus and Grafana integration&#10;5. **API Gateway**: REST API for management and monitoring&#10;&#10;### Scalability Improvements&#10;1. **Connection Multiplexing**: Multiple connections over single NATS connection&#10;2. **Compression**: Data compression for better performance&#10;3. **Caching**: Response caching for frequently accessed data&#10;4. **Rate Limiting**: Configurable rate limiting per connection&#10;&#10;### Security Enhancements&#10;1. **mTLS**: Mutual TLS authentication&#10;2. **OAuth2**: OAuth2 integration for authentication&#10;3. **RBAC**: Role-based access control&#10;4. **Audit Trail**: Comprehensive audit logging&#10;" />
              <option name="updatedContent" value="# NATS TCP Proxy - Architecture Documentation&#10;&#10;## Overview&#10;&#10;The NATS TCP Proxy is a high-performance TCP proxy that uses NATS (Neural Autonomic Transport System) as the transport layer for proxying TCP connections between client and server. The project follows Domain-Driven Design (DDD) methodology with a clean architecture approach.&#10;&#10;## Architecture Layers&#10;&#10;### 1. Domain Layer (`internal/domain/`)&#10;&#10;The domain layer contains the core business logic and is independent of external concerns.&#10;&#10;#### Entities (`internal/domain/entities/`)&#10;- **Connection**: Represents a TCP connection between client and server&#10;  - Properties: ID, ClientAddr, ServerAddr, CreatedAt, LastActivity, Status&#10;  - Methods: UpdateActivity(), SetStatus(), IsActive(), Close(), etc.&#10;&#10;#### Value Objects (`internal/domain/valueobjects/`)&#10;- **ConnectionID**: Unique identifier for connections&#10;  - Immutable and self-validating&#10;  - Methods: String(), Equals(), IsZero()&#10;&#10;#### Domain Services (`internal/domain/services/`)&#10;- **ProxyService**: Core business logic for handling proxy connections&#10;  - Methods: ProxyConnection(), GetConnectionStats(), CloseConnection()&#10;  - Handles bidirectional data flow between client and remote server&#10;&#10;#### Repositories (`internal/domain/repositories/`)&#10;- **ConnectionRepository**: Interface for connection persistence&#10;  - Methods: Store(), GetByID(), GetActive(), GetAll(), Update(), Delete(), Cleanup()&#10;&#10;### 2. Application Layer (`internal/application/`)&#10;&#10;The application layer orchestrates domain objects and implements use cases.&#10;&#10;#### Use Cases (`internal/application/usecases/`)&#10;- **ProxyUseCase**: Application logic for proxy operations&#10;  - Methods: HandleNewConnection(), GetConnectionStats(), CleanupOldConnections()&#10;  - Coordinates between domain services and infrastructure&#10;&#10;### 3. Infrastructure Layer (`internal/infrastructure/`)&#10;&#10;The infrastructure layer handles external concerns like transport and persistence.&#10;&#10;#### Transport (`internal/infrastructure/transport/`)&#10;- **NATSTransport**: NATS implementation of the abstract transport interface&#10;  - Handles connection to NATS server&#10;  - Manages message publishing/subscribing&#10;  - Implements request-reply pattern&#10;&#10;#### Repositories (`internal/infrastructure/repositories/`)&#10;- **InMemoryConnectionRepository**: In-memory implementation of ConnectionRepository&#10;  - Thread-safe connection storage&#10;  - Provides statistics and cleanup functionality&#10;&#10;### 4. Interface Layer (`cmd/`)&#10;&#10;The interface layer handles user interaction and external APIs.&#10;&#10;#### CLI Commands (`cmd/client/` and `cmd/server/`)&#10;- **Client**: Listens on local port and forwards connections through NATS&#10;- **Server**: Receives NATS messages and forwards to remote server&#10;- Both use Cobra for CLI framework and Viper for configuration&#10;&#10;## Transport Layer&#10;&#10;### Abstract Transport Interface (`pkg/transport/`)&#10;&#10;```go&#10;type Transport interface {&#10;    Connect(ctx context.Context, config interface{}) error&#10;    Disconnect(ctx context.Context) error&#10;    Send(ctx context.Context, subject string, message *Message) error&#10;    Subscribe(ctx context.Context, subject string) (&lt;-chan *Message, error)&#10;    Request(ctx context.Context, subject string, message *Message) (*Message, error)&#10;    Publish(ctx context.Context, subject string, message *Message) error&#10;    Close() error&#10;    IsConnected() bool&#10;}&#10;```&#10;&#10;### NATS Implementation&#10;&#10;The NATS transport implementation provides:&#10;- **Connection Management**: Automatic reconnection and error handling&#10;- **Message Serialization**: JSON-based message format&#10;- **Subject-based Routing**: Uses NATS subjects for message routing&#10;- **Request-Reply Pattern**: Supports synchronous request-response&#10;- **Publish-Subscribe**: Supports asynchronous message broadcasting&#10;&#10;## Data Flow&#10;&#10;### Client-Side Flow&#10;&#10;1. **Connection Acceptance**: Client listens on local port&#10;2. **NATS Connection**: Establishes connection to NATS server&#10;3. **Message Forwarding**: Reads from client connection and publishes to NATS with remote target info&#10;4. **Response Handling**: Subscribes to response subject and forwards to client&#10;&#10;### Server-Side Flow&#10;&#10;1. **NATS Subscription**: Subscribes to request subjects&#10;2. **Worker Creation**: Creates separate worker for each connection&#10;3. **Remote Connection**: Worker establishes connection to client-specified remote target&#10;4. **Data Forwarding**: Forwards data between NATS and remote server&#10;5. **Response Publishing**: Publishes responses back to NATS&#10;&#10;### Message Format&#10;&#10;```json&#10;{&#10;  &quot;id&quot;: &quot;connection_id&quot;,&#10;  &quot;data&quot;: &quot;base64_encoded_data&quot;,&#10;  &quot;metadata&quot;: {&#10;    &quot;response_subject&quot;: &quot;proxy.response.conn_id&quot;,&#10;    &quot;client_addr&quot;: &quot;127.0.0.1:54321&quot;,&#10;    &quot;remote_host&quot;: &quot;localhost&quot;,&#10;    &quot;remote_port&quot;: &quot;6379&quot;&#10;  }&#10;}&#10;```&#10;&#10;## Configuration&#10;&#10;### Server Configuration&#10;&#10;- `--nats-url`: NATS server URL (default: nats://localhost:4222)&#10;- `--remote-host`: Target remote host&#10;- `--remote-port`: Target remote port&#10;- `--listen-addr`: Address to listen on (default: :8080)&#10;- `--log-level`: Log level (debug, info, warn, error)&#10;&#10;### Client Configuration&#10;&#10;- `--nats-url`: NATS server URL (default: nats://localhost:4222)&#10;- `--local-port`: Local port to listen on&#10;- `--listen-addr`: Local address to listen on (default: localhost)&#10;- `--log-level`: Log level (debug, info, warn, error)&#10;&#10;## Error Handling&#10;&#10;### Connection Errors&#10;- **NATS Connection**: Automatic reconnection with exponential backoff&#10;- **Remote Connection**: Timeout handling and graceful degradation&#10;- **Client Connection**: Proper cleanup and resource management&#10;&#10;### Message Errors&#10;- **Serialization**: JSON marshaling/unmarshaling error handling&#10;- **Transport**: Network timeout and retry logic&#10;- **Validation**: Input validation and sanitization&#10;&#10;## Performance Considerations&#10;&#10;### Connection Management&#10;- **Connection Pooling**: Reuses connections where possible&#10;- **Timeout Handling**: 30-second timeouts prevent hanging connections&#10;- **Buffer Management**: 32KB buffers for efficient data transfer&#10;&#10;### Memory Management&#10;- **Garbage Collection**: Proper cleanup of closed connections&#10;- **Memory Leaks**: Regular cleanup of old connections&#10;- **Resource Limits**: Configurable limits for concurrent connections&#10;&#10;### Scalability&#10;- **Horizontal Scaling**: Multiple clients can connect to same server&#10;- **Load Balancing**: NATS can distribute load across multiple servers&#10;- **High Availability**: NATS clustering for fault tolerance&#10;&#10;## Security Considerations&#10;&#10;### Network Security&#10;- **TLS Support**: NATS supports TLS for encrypted communication&#10;- **Authentication**: NATS authentication and authorization&#10;- **Firewall**: Proper firewall configuration for proxy ports&#10;&#10;### Data Security&#10;- **Message Encryption**: Optional message encryption&#10;- **Access Control**: Port and IP-based access control&#10;- **Audit Logging**: Comprehensive logging for security auditing&#10;&#10;## Monitoring and Observability&#10;&#10;### Metrics&#10;- **Connection Count**: Active, closed, and error connections&#10;- **Data Transfer**: Bytes transferred in each direction&#10;- **Response Times**: Connection establishment and data transfer times&#10;&#10;### Logging&#10;- **Structured Logging**: JSON-formatted logs with correlation IDs&#10;- **Log Levels**: Configurable log levels for different environments&#10;- **Log Rotation**: Automatic log rotation and cleanup&#10;&#10;### Health Checks&#10;- **NATS Connectivity**: Regular health checks for NATS connection&#10;- **Remote Connectivity**: Health checks for remote server connection&#10;- **Resource Usage**: Memory and CPU usage monitoring&#10;&#10;## Deployment&#10;&#10;### Local Development&#10;```bash&#10;# Build the project&#10;make build&#10;&#10;# Start server&#10;./bin/server --nats-url nats://localhost:4222&#10;&#10;# Start client&#10;./bin/client --local-port 6380 --remote-host localhost --remote-port 6379&#10;```&#10;&#10;### Production Deployment&#10;1. **Containerization**: Docker images for easy deployment&#10;2. **Orchestration**: Kubernetes manifests for container orchestration&#10;3. **Service Discovery**: Integration with service discovery systems&#10;4. **Configuration Management**: Environment-based configuration&#10;&#10;### Docker Deployment&#10;&#10;The server can be deployed using Docker with the provided configuration:&#10;&#10;```bash&#10;# Build and run with Docker&#10;./scripts/docker-server.sh build&#10;./scripts/docker-server.sh run&#10;&#10;# Or use Docker Compose for full stack&#10;./scripts/docker-server.sh compose&#10;```&#10;&#10;**Docker Features:**&#10;- **Multi-stage build** for optimized image size&#10;- **Non-root user** for security&#10;- **Health checks** for monitoring&#10;- **Environment variables** for configuration&#10;- **Docker Compose** for complete stack deployment&#10;&#10;### High Availability&#10;1. **NATS Clustering**: Multiple NATS servers for redundancy&#10;2. **Load Balancing**: Multiple proxy servers behind load balancer&#10;3. **Health Checks**: Automated health checks and failover&#10;4. **Backup and Recovery**: Regular backups and disaster recovery&#10;&#10;## Testing Strategy&#10;&#10;### Unit Tests&#10;- **Domain Logic**: Tests for entities, value objects, and domain services&#10;- **Repository Tests**: Tests for data access layer&#10;- **Transport Tests**: Tests for NATS transport implementation&#10;&#10;### Integration Tests&#10;- **End-to-End**: Full proxy functionality tests&#10;- **NATS Integration**: Tests with real NATS server&#10;- **Performance Tests**: Load testing and performance benchmarks&#10;&#10;### Acceptance Tests&#10;- **Redis Proxy**: Complete Redis proxy scenario&#10;- **Multiple Connections**: Tests with multiple concurrent connections&#10;- **Error Scenarios**: Tests for various error conditions&#10;&#10;## Future Enhancements&#10;&#10;### Planned Features&#10;1. **Multiple Transport Support**: gRPC, WebSocket, and other transport layers&#10;2. **Protocol Support**: HTTP, HTTPS, and other protocols&#10;3. **Advanced Routing**: Content-based routing and load balancing&#10;4. **API Gateway**: REST API for management and monitoring&#10;&#10;### Scalability Improvements&#10;1. **Connection Multiplexing**: Multiple connections over single NATS connection&#10;2. **Compression**: Data compression for better performance&#10;3. **Caching**: Response caching for frequently accessed data&#10;4. **Rate Limiting**: Configurable rate limiting per connection&#10;&#10;### Security Enhancements&#10;1. **mTLS**: Mutual TLS authentication&#10;2. **RBAC**: Role-based access control&#10;3. **Audit Trail**: Comprehensive audit logging" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>